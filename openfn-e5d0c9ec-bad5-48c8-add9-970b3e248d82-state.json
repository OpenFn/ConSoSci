{
  "id": "e5d0c9ec-bad5-48c8-add9-970b3e248d82",
  "name": "social-sciences",
  "description": "Workflows for WCS & Partners in Social Sciences\n",
  "concurrency": null,
  "inserted_at": "2025-03-10T07:28:21Z",
  "updated_at": "2025-03-18T08:52:20Z",
  "scheduled_deletion": null,
  "project_credentials": {
    "rediet@openfn.org-Rediet-Googlesheet": {
      "id": "8f098581-1fba-449e-b7e5-49d7e8edc66b",
      "name": "Rediet Googlesheet",
      "owner": "rediet@openfn.org"
    },
    "rediet@openfn.org-WCS-Kobo": {
      "id": "f9c29826-894a-4f02-a120-f6bab5d16224",
      "name": "WCS Kobo",
      "owner": "rediet@openfn.org"
    },
    "rediet@openfn.org-WCS-Kobo-Raw": {
      "id": "50000511-d991-4efd-b41e-030dc4d9373a",
      "name": "WCS Kobo Raw",
      "owner": "rediet@openfn.org"
    },
    "rediet@openfn.org-WCS-MSSQL-Test-DB": {
      "id": "b5fa2c78-00ab-4795-92d0-1078e7789aaa",
      "name": "WCS MSSQL Test DB",
      "owner": "rediet@openfn.org"
    },
    "aisha@openfn.org-AK-Asana": {
      "id": "4eb4c277-68ae-4d71-a569-3584b2cc4719",
      "name": "AK Asana",
      "owner": "aisha@openfn.org"
    },
    "rediet@openfn.org-WCS-Kobo-Raw-with-URL": {
      "id": "950c9c55-fb89-4d8c-ab24-e2ca04a38ba7",
      "name": "WCS Kobo Raw with URL",
      "owner": "rediet@openfn.org"
    }
  },
  "history_retention_period": 7,
  "dataclip_retention_period": null,
  "retention_policy": "retain_all",
  "collections": {},
  "workflows": {
    "1B.-Get-BNS-FormsList-Historical-sync": {
      "id": "d064ad3d-f301-4071-9af3-77ede0dab5f6",
      "name": "1B. Get BNS FormsList Historical sync",
      "inserted_at": "2025-03-18T09:46:53.962751Z",
      "lock_version": 31,
      "triggers": {
        "cron": {
          "enabled": false,
          "id": "8c2a16dd-f19c-4e71-8ef6-3f06e9806b43",
          "type": "cron",
          "cron_expression": "0 22 1 * *"
        }
      },
      "jobs": {
        "BNS-1B-1-Get-FormsList-Historical-sync": {
          "id": "31883ef6-acc3-4cc3-bfca-647c18897496",
          "name": "BNS-1B 1 Get FormsList Historical sync",
          "body": "getValues(\n  '1xexwj6HKJGHJM-sOzIOGqPHolgpdnp0GmjMIXwoV7OE',\n  'wcs-bns-DEPLOYED!A:O', //get Deployed forms list from Sheet\n  state => {\n    const [headers, ...values] = state.data.values;\n\n    const mapHeaderToValue = value => {\n      return headers.reduce((obj, header) => {\n        obj[header] = value[headers.indexOf(header)];\n        return obj;\n      }, {});\n    };\nconsole.log(\"deployedData\", values);\n\n    state.deployedData = values\n      .map(item => mapHeaderToValue(item))\n      .filter(item => item['historical_sync'] === 'TRUE');\n    return state;\n  }\n);\n//== Job to be used for getting a list of \"archived\" Kobo forms from sheets to auto-sync  ==//\n// This can be run on-demand at any time by clicking \"run\" //\ngetValues(\n  '1xexwj6HKJGHJM-sOzIOGqPHolgpdnp0GmjMIXwoV7OE',\n  'wcs-bns-ARCHIVED!A:O', //get Deployed forms list from Sheet\n  state => {\n    const [headers, ...values] = state.data.values;\n\n    const mapHeaderToValue = value => {\n      return headers.reduce((obj, header) => {\n        obj[header] = value[headers.indexOf(header)];\n        return obj;\n      }, {});\n    };\nconsole.log(\"archivedData\", values);\n\n\n    state.archivedData = values\n      .map(item => mapHeaderToValue(item))\n      .filter(item => item['historical_sync'] === 'TRUE');\n\n    return state;\n  }\n);\n\nfn(state => {\n  const { archivedData, deployedData } = state;\n\n  // Set a manual cursor if you'd like to only fetch data after this date...\n  //e.g., '2023-01-01T23:51:45.491+01:00'\n  //   const manualCursor = ''; //lastUsed: 2024-04-01T00:00:00.000Z\n  //   console.log('manualCursor defined?', manualCursor);\n  //...otherwise the job will use this dynamicCursor\n  // const dynamicCursor = getTodayISODate();\n\n  //   function getTodayISODate() {\n  //     const today = new Date();\n  //     today.setUTCHours(0, 0, 0, 0); // Set hours, minutes, seconds, and milliseconds to 0\n  //     return today.toISOString(); // Convert to ISO string\n  //   }\n\n  //   const cursorValue = manualCursor || dynamicCursor;\n  //   console.log('Cursor value to use in query:', cursorValue);\n  const combinedData = [...deployedData, ...archivedData];\n  const formsList = combinedData.map(survey => ({\n    formId: survey.uid,\n    tag: survey.tag,\n    name: survey.name,\n  }));\n\n  console.log('# of forms detected in Sheet:: ', formsList.length);\n  console.log(\n    'List of forms to re-sync:: ',\n    JSON.stringify(formsList, null, 2)\n  );\n\n  state.data = {\n    surveys: combinedData.map(survey => ({\n      formId: survey.uid,\n      tag: survey.tag,\n      name: survey.name,\n      owner: survey.owner,\n      url: `https://kf.kobotoolbox.org/api/v2/assets/${survey.uid}/data/?format=json`,\n      //query: `&query={\"end\":{\"$gte\":\"${cursorValue}\"}}`, //get ALL forms for historical job\n    })),\n  };\n  return state;\n});\n\n//Clear final state\nfn(state => {\n  delete state.references;\n  delete state.response;\n  return state;\n});     \n",
          "adaptor": "@openfn/language-googlesheets@2.3.0",
          "project_credential_id": "8f098581-1fba-449e-b7e5-49d7e8edc66b"
        },
        "Get-BNS-NRGT-Forms-Historical": {
          "id": "e8e4e659-d4f0-4fd3-b109-9d96d885505f",
          "name": "Get BNS NRGT Forms Historical",
          "body": "// Here we fetch submissions for all \"Archived\" forms in GoogleSheet\n// NOTE: See linked job \"[BNS-1B] 1.Get FormsList (Historical)\" for GoogleSheet query logic\n//**********************************************************//\neach(dataPath('surveys[*]'), state => {\n  const { url, tag, formId, name, owner } = state.data;\n  const query = \"&query={\\\"start\\\":{\\\"$gte\\\":\\\"2021-10-29T00:00:00.000Z\\\"}}\"\n  return get(`${url}${query}`, {}, state => {\n    console.log(state.data.result)\n    state.data.submissions = state.data.results.map((submission, i) => {\n      return {\n        i,\n        // Here we append the tags defined above to the Kobo form submission data\n        form: tag,\n        formName: name,\n        formOwner: owner,\n        body: submission,\n      };\n    });\n    const count = state.data.submissions.length;\n    console.log('Finding historical forms to resync...');\n    console.log(`Fetched ${count} submissions from ${formId} (${tag}).`);\n    //Once we fetch the data, we want to post each individual Kobo survey\n    //back to the OpenFn inbox to run through the jobs =========================\n    return each(dataPath('submissions[*]'), state => {\n      console.log(`Posting ${state.data.i + 1} of ${count}...`);\n      return post(\"https://app.openfn.org/i/b3f86593-f37e-4139-80b8-852b9d3c49f4\", {\n        body: state => state.data,\n      })(state);\n    })(state);\n  })(state)\n});\n",
          "adaptor": "@openfn/language-http@3.1.11",
          "project_credential_id": "50000511-d991-4efd-b41e-030dc4d9373a"
        }
      },
      "edges": {
        "BNS-1B-1-Get-FormsList-Historical-sync->Get-BNS-NRGT-Forms-Historical": {
          "enabled": true,
          "id": "eaf51415-d4e7-41bf-9d38-9d6e5765f78a",
          "target_job_id": "e8e4e659-d4f0-4fd3-b109-9d96d885505f",
          "source_job_id": "31883ef6-acc3-4cc3-bfca-647c18897496",
          "condition_type": "on_job_success"
        },
        "cron->BNS-1B-1-Get-FormsList-Historical-sync": {
          "enabled": true,
          "id": "c9db77c0-2540-40d5-8709-60899c6b4780",
          "target_job_id": "31883ef6-acc3-4cc3-bfca-647c18897496",
          "source_trigger_id": "8c2a16dd-f19c-4e71-8ef6-3f06e9806b43",
          "condition_type": "always"
        }
      }
    },
    "1A.-Get-BNS-FormsList-(Ongoing)": {
      "id": "89b68b57-226e-4696-819f-ab79dc382280",
      "name": "1A. Get BNS FormsList (Ongoing)",
      "inserted_at": "2025-03-18T09:47:05.945181Z",
      "lock_version": 17,
      "triggers": {
        "cron": {
          "enabled": false,
          "id": "b6c56639-4b31-4812-91fe-f327bbf219c1",
          "type": "cron",
          "cron_expression": "0 */3 * * *"
        }
      },
      "jobs": {
        "BNS-1A-1-Get-FormsList-Ongoing": {
          "id": "3936a1b5-88ca-4dda-9021-d1f8d4803dd6",
          "name": "BNS 1A 1 Get FormsList Ongoing",
          "body": "//== Job to be used for getting a list of \"deployed\" Kobo forms from sheets to auto-sync  ==//\n// This can be run on-demand at any time by clicking \"run\" or modify manualCursor below //\ngetValues(\n   '1xexwj6HKJGHJM-sOzIOGqPHolgpdnp0GmjMIXwoV7OE',\n  'wcs-bns-DEPLOYED!A:L', //get Deployed forms list from Sheet\n  state => {\n    const [headers, ...values] = state.data.values;\n\n    const mapHeaderToValue = value => {\n      return headers.reduce((obj, header) => {\n        obj[header] = value[headers.indexOf(header)];\n        return obj;\n      }, {});\n    };\n\n    state.sheetsData = values\n      .filter(\n        item =>\n          item.includes('TRUE') //return forms where auto-sync = TRUE\n          //&& item.includes('bns_survey', 'nrgt_current') \n      )\n      .map(item => mapHeaderToValue(item));\n\n    return state;\n  }\n);\n\nfn(state => {\n  const { sheetsData } = state;\n\n  // Set a manual cursor if you'd like to only fetch data after this date...\n  //e.g., '2023-01-01T23:51:45.491+01:00'\n  const manualCursor = '2024-12-06T00:00:00.000Z';  //lastUsed: 2024-11-21T00:00:00.000Z\n  console.log('manualCursor defined?', manualCursor);\n  \n  //...otherwise the job will use this dynamicCursor\n  const dynamicCursor = getTodayISODate(); \n\n  function getTodayISODate() {\n    const today = new Date();\n    today.setUTCHours(0, 0, 0, 0); // Set hours, minutes, seconds, and milliseconds to 0\n    return today.toISOString(); // Convert to ISO string\n  }\n  \n  //UNCOMMENT FOR FUTURE\n // const cursorValue = dynamicCursor || manualCursor ; \n  const cursorValue = manualCursor ; \n \n  // const cursorValue = manualCursor ; \n  console.log('Cursor value to use in query:', cursorValue);\n\n  const formsList = sheetsData.map(survey => ({\n      formId: survey.uid,\n      tag: survey.tag,\n      name: survey.name \n  })); \n  \n  console.log('# of deployed forms detected in Sheet:: ', formsList.length);\n  console.log('List of forms to auto-sync:: ', JSON.stringify(formsList, null, 2)); \n\n  state.data = {\n    surveys: sheetsData.map(survey => ({\n      formId: survey.uid,\n      tag: survey.tag,\n      name: survey.name,\n      owner: survey.owner,\n      url: `https://kf.kobotoolbox.org/api/v2/assets/${survey.uid}/data/?format=json`,\n      query: `&query={\"start\":{\"$gte\":\"${cursorValue}\"}}`,\n    })),\n  };\n  return state;\n});\n",
          "adaptor": "@openfn/language-googlesheets@2.3.0",
          "project_credential_id": "8f098581-1fba-449e-b7e5-49d7e8edc66b"
        },
        "BNS-1A-Get-BNS-NRGT-Forms-Ongoing": {
          "id": "6a095185-628e-4e8f-bee4-e39c601c2b30",
          "name": "BNS 1A Get BNS NRGT Forms Ongoing",
          "body": "// Here we fetch submissions for all \"Deployed\" forms in GoogleSheet\n// NOTE: See linked job \"[BNS-1A] 1.Get FormsList (Ongoing)\" for cursor & GoogleSheet query logic\n//**********************************************************//\n\nfn(state => {\n  state.surveySubmissions = [];\n  state.errors = [];\n  state.globalIndex = 0;\n  console.log('surveys ::', JSON.stringify(state.data.surveys, null, 2));\n  return state;\n});\n\neach('$.data.surveys[*]', state => {\n  const { url, query, tag, formId, name, owner } = state.data;\n  console.log('Sending GET to ::', `${url}${query}`);\n\n  return get(`${url}${query}`)(state)\n    .then(state => {\n      const results = state.data.results.map(submission => {\n        const uniqueIndex = state.globalIndex++;\n        return {\n          i: uniqueIndex,\n          // Here we append the tags defined above to the Kobo form submission data\n          form: tag,\n          formName: name,\n          formOwner: owner,\n          body: submission,\n        };\n      });\n\n      state.surveySubmissions.push(...results);\n      const count = results.length;\n      console.log(`Fetched ${count} submissions from ${formId} (${tag}).`);\n      //Once we fetch the data, we want to post each individual Kobo survey\n      //back to the OpenFn inbox to run through the jobs =========================\n      return state;\n    })\n    .catch(err => {\n      state.errors.push({\n        formId,\n        message: err.message,\n      });\n      console.log(`Error fetching submissions from  ${formId}::`, err.message);\n      return state;\n    });\n});\n\n// each(\n//   '$.surveySubmissions[*]',\n//   post(\n//     state => state.configuration.openfnInboxUrl,\n//     state => {\n//       const {i, formName} = state.data;\n//       const count = state.surveySubmissions.length;\n//       console.log(`Posting ${i} of ${count} from ${formName}`);\n//       return { body: state.data };\n//     }\n//   )\n// );  \n",
          "adaptor": "@openfn/language-http@6.1.0",
          "project_credential_id": "50000511-d991-4efd-b41e-030dc4d9373a"
        },
        "Trigger-WF-Inbox": {
          "id": "3a313448-32b0-4638-8853-d5f91e100698",
          "name": "Trigger WF Inbox",
          "body": "// Check out the Job Writing Guide for help getting started:\n// https://docs.openfn.org/documentation/jobs/job-writing-guide\neach(\n  '$.surveySubmissions[*]',\n  post(\n   \"https://app.openfn.org/i/b3f86593-f37e-4139-80b8-852b9d3c49f4\",\n    state => {\n      const {i, formName} = state.data;\n      const count = state.surveySubmissions.length;\n      console.log(`Posting ${i} of ${count} from ${formName}`);\n      return { body: state.data };\n    }\n  )\n);  ",
          "adaptor": "@openfn/language-http@latest",
          "project_credential_id": null
        }
      },
      "edges": {
        "cron->BNS-1A-1-Get-FormsList-Ongoing": {
          "enabled": true,
          "id": "c3fd057e-7257-4ba3-924f-7e90170a0d10",
          "target_job_id": "3936a1b5-88ca-4dda-9021-d1f8d4803dd6",
          "source_trigger_id": "b6c56639-4b31-4812-91fe-f327bbf219c1",
          "condition_type": "always"
        },
        "BNS-1A-1-Get-FormsList-Ongoing->BNS-1A-Get-BNS-NRGT-Forms-Ongoing": {
          "enabled": true,
          "id": "900d23a9-5f96-447d-8d45-444ebff8b56b",
          "target_job_id": "6a095185-628e-4e8f-bee4-e39c601c2b30",
          "source_job_id": "3936a1b5-88ca-4dda-9021-d1f8d4803dd6",
          "condition_type": "on_job_success"
        },
        "BNS-1A-Get-BNS-NRGT-Forms-Ongoing->Trigger-WF-Inbox": {
          "enabled": true,
          "id": "db86ef04-bcfd-42a3-8fe9-c38f8d6c66f9",
          "target_job_id": "3a313448-32b0-4638-8853-d5f91e100698",
          "source_job_id": "6a095185-628e-4e8f-bee4-e39c601c2b30",
          "condition_type": "on_job_success"
        }
      }
    },
    "2.-Sync-BNS-and-NRGT-Forms": {
      "id": "83fd9ae8-4dc6-4dd9-bc9b-f5940c5d8ef5",
      "name": "2. Sync BNS and NRGT Forms",
      "inserted_at": "2025-03-18T09:47:23.159948Z",
      "lock_version": 35,
      "triggers": {
        "webhook": {
          "enabled": true,
          "id": "b3f86593-f37e-4139-80b8-852b9d3c49f4",
          "type": "webhook"
        }
      },
      "jobs": {
        "Triage-jobs": {
          "id": "65e96922-0db6-4823-88ea-64601641c902",
          "name": "Triage jobs",
          "body": "// Check out the Job Writing Guide for help getting started:\n// https://docs.openfn.org/documentation/jobs/job-writing-guide\n",
          "adaptor": "@openfn/language-common@latest",
          "project_credential_id": null
        },
        "BNS-2A-BNS-Price": {
          "id": "7280bfa9-2a67-4c6e-8a3a-f7f21bcb26ae",
          "name": "BNS-2A BNS Price",
          "body": "// NOTE: This data cleaning operation returns state, modified as needed.\nfn(state => {\n  //try {\n  const { body, formName, instance, formOwner } = state.data;\n  const { _submission_time, _id, _xform_id_string } = body;\n  let cleanedSubmission = {};\n\n  for (const key in body) {\n    switch (body[key]) {\n      case 'yes':\n        cleanedSubmission[key] = 1;\n        break;\n\n      case 'no':\n        cleanedSubmission[key] = 0;\n        break;\n\n      default:\n        cleanedSubmission[key] = body[key];\n        break;\n    }\n  }\n\n  cleanedSubmission.instance = instance;\n\n  const landscapeMap = {\n    Ndoki: 'ndoki',\n    'Lac Télé': 'lac_tele',\n    Ituri: 'ituri',\n    Kahuzi: 'kahuzi',\n    MTKB: 'kahuzi',\n    'Cross River': 'crossriver',\n    Soariake: 'soariake',\n    Ankarea: 'ankarea',\n    ABS: 'baie_antongil',\n    'Nosy Be': 'tandavandriva',\n    Makira: 'makira',\n    'BNS Ndoki Prix 2020': 'ndoki',\n    PNMD: 'pnmd',\n\n    //formName: landscapeValue,\n    //other values\n  };\n\n  return {\n    ...state,\n    landscapeMap,\n    formName,\n    formOwner,\n    data: {\n      ...cleanedSubmission,\n      durableUUID: `${_submission_time}-${_xform_id_string}-${_id}`,\n      datasetId: `${formName}-${_xform_id_string}`,\n      end: cleanedSubmission.end.slice(0, 10),\n    },\n  };\n  /* } catch (error) {\n    state.connection.close();\n    throw error;\n  }*/\n});\n\n// Refactor this for scale so it doesn't perform a no-op delete 9/10 times.\n// Maybe check result of previous op, then only delete if it was an update.\nsql({\n  query: state =>\n    `DELETE FROM WCSPROGRAMS_KoboBnsPrice where AnswerId = '${state.data._id}'`,\n});\n\nfn(state => {\n  const { good } = state.data;\n  if (!good || good.length === 0) {\n    return state;\n  }\n\n  const data = good.map((g, i) => ({\n    // Id: state.data._id,\n    Id: i + 1,\n    AnswerId: state.data._id,\n    DatasetUuidId: state.data.datasetId,\n    Surveyor: state.data.surveyor,\n    Village: state.data.village,\n    Gs: g[`good/name`],\n    Price: g[`good/price`],\n    LastUpdate: new Date().toISOString(),\n    //Landscape: state.landscapeMap[state.data.formName], //see L24 for mappings. We want to use formName to look-up a new value\n    Landscape: () => {\n      for (let val in state.landscapeMap)\n        if (state.formName.includes(val)) return state.landscapeMap[val];\n      return '';\n    },\n    SurveyDate: state.data.today,\n  }));\n  // console.log('data', data);\n  return insertMany('WCSPROGRAMS_KoboBnsPrice', data)(state);\n});\n\nfn(state => {\n  console.log('DatasetName ::', state.formName);\n  console.log('DatasetOwner ::', state.formOwner);\n  console.log('form submission id ::', state.data['_id']);\n  console.log('DatasetUuidId ::', state.data['datasetId']);\n  //console.log('data to upload ::', state.data);\n  return state;\n});\n\nupsert('WCSPROGRAMS_KoboData', 'DatasetUuidId', {\n  //AnswerId: dataValue('durableUUID'),\n  DatasetName: state => state.formName,\n  DatasetOwner: state => state.formOwner,\n  Landscape: dataValue('landscape'),\n  DatasetUuidId: dataValue('datasetId'),\n  DatasetYear: new Date().getFullYear(),\n  LastSubmissionTime: dataValue('_submission_time'),\n  LastCheckedTime: dataValue('_submission_time'),\n  LastUpdateTime: new Date().toISOString(),\n  KoboManaged: true,\n  Tags: dataValue('_tags'),\n  Citation: dataValue('instance'),\n});\n\nfn(state => {\n  console.log('data uploaded ::', state.data);\n  return state;\n});\n",
          "adaptor": "@openfn/language-mssql@3.0.0",
          "project_credential_id": "b5fa2c78-00ab-4795-92d0-1078e7789aaa"
        },
        "BNS-2B-BNS-Survey": {
          "id": "196697f9-b581-4397-8487-280df2d47529",
          "name": "BNS 2B BNS Survey",
          "body": "// NOTE: This data cleaning operation returns state, modified as needed.\n\nfn(state => {\n  try {\n    const { body, formName, formOwner, instance } = state.data;\n    const { _submission_time, _id, _xform_id_string } = body;\n\n    let cleanedSubmission = {};\n\n    for (const key in body) {\n      switch (body[key]) {\n        case 'yes':\n          cleanedSubmission[key] = 1;\n          break;\n\n        case 'no':\n          cleanedSubmission[key] = 0;\n          break;\n\n        default:\n          cleanedSubmission[key] = body[key];\n          break;\n      }\n    }\n\n    // NOTE: This assumes all device-collected geo data follows specific lat, log data format\n    if (cleanedSubmission.gps_method === 'device') {\n      cleanedSubmission['gps/lat'] =\n        cleanedSubmission.geo && cleanedSubmission.geo.split(' ')[0];\n      cleanedSubmission['gps/long'] =\n        cleanedSubmission.geo && cleanedSubmission.geo.split(' ')[1];\n    } else if (\n      Math.abs(parseFloat(cleanedSubmission['gps/lat'])) > 90 ||\n      Math.abs(parseFloat(cleanedSubmission['gps/long'])) > 180\n    ) {\n      console.log(\n        `WARNING: Discarding invalid manual GPS entry: 'gps/lat': ${cleanedSubmission['gps/lat']}; 'gps/long': ${cleanedSubmission['gps/long']}`\n      );\n      delete cleanedSubmission['gps/lat'];\n      delete cleanedSubmission['gps/long'];\n    }\n\n    cleanedSubmission.durableUUID = `${_submission_time}-${_xform_id_string}-${_id}`; //survey uuid\n    cleanedSubmission.datasetId = `${formName}-${_xform_id_string}`; //dataset uuid\n    cleanedSubmission.instance = instance;\n    state.data = cleanedSubmission;\n\n    state.landscapeMap = {\n      tns: 'ndoki',\n      ltlt: 'lac_tele',\n      mamabay: 'makira',\n      mtkb: 'kahuzi',\n    };\n\n    // Cleaning datasetId if formName is 'BNS Cross River 2017-2020'==============\n    if (formName.replace(/\\s/g, '') === 'BNSCrossRiver2017-2020') {\n      state.data.datasetId = `${state.data.datasetId}${\n        body.today.split('-')[0]\n      }`;\n    }\n\n    // ===========================================================================\n\n    // ===========================================================================\n    //  NOTE: These job mappings assume a specific Kobo form metadata naming syntax!\n    //  'NR' and 'BNS matrix' questions should follow the naming conventions below\n    //  See Docs to learn more about the assumptions made here.\n    // ===========================================================================\n    // If a partner creates a form with slightly different field names, this\n    // section will need to be updated by WCS. If future forms are being designed,\n    // we'd recommend using a repeat group that allows the partner to select the\n    // type of 'nr' or 'matrix' they're reporting on. The current approach treats\n    // the form field names in Kobo _AS_ data themselves.\n    state.nr = Object.keys(state.data)\n      .filter(key => key.startsWith('nr/'))\n      .map(key => ({\n        DatasetUuidId: state.data.datasetId,\n        AnswerId: state.data._id,\n        Id: state.data._id,\n        LastUpdate: new Date().toISOString(),\n        Nr: key.substring(3),\n        NrCollect: state.data[key],\n      }));\n\n    const matrix = Object.keys(state.data)\n      .filter(key => key.includes('bns_matrix_'))\n      .map(key => {\n        const item = key.substring(\n          key.lastIndexOf('bns_matrix_') + 'bns_matrix_'.length,\n          key.lastIndexOf('_')\n        );\n        return {\n          Dataset_Id: state.data.datasetId, //DatasetUuidId\n          DatasetUuidId: state.data.datasetId,\n          //Id: state.data._id,\n          AnswerId: state.data._id,\n          gs: item.replace(/_/g, ' '),\n          have:\n            state.data[\n              `hh_assets/bns_matrix_${item}/bns_matrix_${item}_possess`\n            ] || state.data[`bns_matrix_${item}/bns_matrix_${item}_possess`],\n          necessary:\n            state.data[\n              `hh_assets/bns_matrix_${item}/bns_matrix_${item}_necessary`\n            ] || state.data[`bns_matrix_${item}/bns_matrix_${item}_necessary`],\n          quantity:\n            state.data[\n              `hh_assets/bns_matrix_${item}/bns_matrix_${item}_number`\n            ] || state.data[`bns_matrix_${item}/bns_matrix_${item}_number`],\n        };\n      });\n\n    state.matrix = matrix.filter(\n      (x, i) => matrix.findIndex(y => y.gs == x.gs) == i\n    );\n    // ===========================================================================\n    // console.log(\n    //   'The bns_matrix',\n    //   JSON.stringify(state.matrix, null, 2),\n    //   `contains ${state.matrix.length} items.`\n    // );\n    console.log('instance: ', instance);\n    return {...state, formOwner, formName};\n  } catch (error) {\n    state.connection.close();\n    throw error;\n  }\n});\n\nupsert('WCSPROGRAMS_KoboBnsAnswer', 'AnswerId', {\n  DatasetUuidId: dataValue('datasetId'),\n  //Id: dataValue('durableUUID'), //Q: does not exist, to add for consistency?\n  SubmissionUuid: dataValue('_uuid'),\n  AnswerId: dataValue('_id'),\n  LastUpdate: new Date().toISOString(),\n  SurveyDate: state => {\n    const date = state.data.today || state.data._submission_time;\n    const year = Number(date.trim().split('-')[0]);\n    const formName = dataValue('formName');\n    if (year <= 2010) return Number(formName.trim().split(' ').at(-1));\n    return year;\n  },\n  Landscape: state => {\n    var landscape = dataValue('landscape')(state);\n    return state.landscapeMap[landscape] || landscape;\n  },\n  Surveyor: dataValue('surveyor'),\n  Participant: dataValue('participant'),\n  Arrival: dataValue('arrival'),\n  District: dataValue('district'),\n  Village: dataValue('village'),\n  HhId: dataValue('hh_id'),\n  BenefProject: dataValue('benef_project'),\n  HhTypeControl: state => (state.data.hh_type === 'control' ? 1 : 0),\n  HhTypeOrgBenef: state => (state.data.hh_type === 'wcs_benef' ? 1 : 0),\n  HhTypeOtherBenef: state => (state.data.hh_type === 'other_benef' ? 1 : 0),\n  ExplainProject: dataValue('explain_project'),\n  KnowPa: dataValue('know_PA'),\n  BenefPa: dataValue('benef_PA'),\n  ExplainBenefPa: dataValue('explain_benef_PA'),\n  Livelihood1: dataValue('livelihoods/l1'),\n  Livelihood2: dataValue('livelihoods/l2'),\n  Livelihood3: dataValue('livelihoods/l3'),\n  Livelihood4: dataValue('livelihoods/l4'),\n  BnsPlus: dataValue('bns_plus'),\n});\n\n// Refactor this for scale so it doesn't perform a no-op delete 9/10 times.\n// Maybe check result of previous op, then only delete if it was an update.\nsql({\n  query: state =>\n    `DELETE FROM WCSPROGRAMS_KoboBnsAnswerhhmembers where AnswerId = '${state.data._id}'`,\n});\n\ninsert('WCSPROGRAMS_KoboBnsAnswerhhmembers', {\n  //insert hh head first\n  DatasetUuidId: dataValue('datasetId'),\n  Id: '0',\n  //Id: state => state.data.hh_members.length,\n  AnswerId: dataValue('_id'),\n  Head: dataValue('gender_head') ? '1' : '0',\n  Gender: dataValue('gender_head'),\n  Ethnicity: dataValue('ethnicity_head'),\n  Birth: state => {\n    var birth = dataValue('birth_head')(state);\n    return birth ? parseInt(birth.substring(0, 4)) : null;\n  },\n  LastUpdate: new Date().toISOString(),\n});\n\nfn(state => {\n  if (state.data.hh_members) {\n    return insertMany(\n      'WCSPROGRAMS_KoboBnsAnswerhhmembers',\n      (\n        state //then insert other members\n      ) =>\n        state.data.hh_members.map((member, i) => ({\n          DatasetUuidId: state.data.datasetId,\n          // Id: state.data._id,\n          Id: i + 1,\n          AnswerId: state.data._id,\n          Head: '0',\n          Gender:\n            member[`hh_members/gender`] || member[`hh_members/gender_001`],\n          Ethnicity: member[`hh_members/ethnicity`],\n          Birth: parseInt(member[`hh_members/birth`].substring(0, 4)),\n          LastUpdate: new Date().toISOString(),\n        }))\n    )(state);\n  }\n\n  console.log('No household members found.');\n  return state;\n});\n\n// Refactor this for scale so it doesn't perform a no-op delete 9/10 times.\n// Maybe check result of previous op, then only delete if it was an update.\nsql({\n  query: state =>\n    `DELETE FROM WCSPROGRAMS_KoboBnsAnswernr where AnswerId = '${state.data._id}'`,\n});\n\nfn(state => {\n  if (state.nr && state.nr.length > 0) {\n    return insertMany('WCSPROGRAMS_KoboBnsAnswernr', state => state.nr)(state);\n  }\n\n  console.log('No natural resource found.');\n  return state;\n});\n\n// Refactor this for scale so it doesn't perform a no-op delete 9/10 times.\n// Maybe check result of previous op, then only delete if it was an update.\n//sql({ query: state => `DELETE FROM WCSPROGRAMS_KoboBnsAnswergs where AnswerId = '${state.data._id}'` }); //ERROR: AnswerId does not exist\nsql({\n  query: state =>\n    `DELETE FROM WCSPROGRAMS_KoboBnsAnswerGS where AnswerId = '${state.data._id}'`,\n});\n\nfn(state => {\n  if (state.matrix && state.matrix.length > 0) {\n    return insertMany(\n      'WCSPROGRAMS_KoboBnsAnswerGS',\n      state => state.matrix\n    )(state);\n  }\n\n  console.log('No matrix found.');\n  return state;\n});\n\nupsert('WCSPROGRAMS_KoboBnsAnswergps', 'AnswerId', {\n  DatasetUuidId: dataValue('datasetId'), //Q: Add new column\n  AnswerId: dataValue('_id'),\n  Id: dataValue('_id'),\n  Geom: dataValue('_geolocation'),\n  Lat: state => {\n    return dataValue('gps/lat')(state)\n      ? dataValue('gps/lat')(state)\n      : state.data._geolocation[0] || undefined;\n  },\n  Long: state => {\n    return dataValue('gps/long')(state)\n      ? dataValue('gps/long')(state)\n      : state.data._geolocation[1] || undefined;\n  },\n  LastUpdate: new Date().toISOString(),\n});\n\nfn(state => {\n  console.log('DatasetName ::', state.formName);\n  console.log('DatasetOwner ::', state.formOwner);\n  console.log('form submission id ::', state.data['_id']);\n  console.log('DatasetUuidId ::', state.data['datasetId']);\n  //console.log('data to upload ::', state.data);\n  return state;\n})\n\nupsert('WCSPROGRAMS_KoboData', 'DatasetUuidId', {\n  //renamed from DatasetUuid\n  //AnswerId: dataValue('_id'), //KoboData = 1 Dataset (not 1 survey)\n  DatasetName: state => state.formName,\n  DatasetOwner: state => state.formOwner,\n  Landscape: dataValue('landscape'),\n  DatasetUuidId: dataValue('datasetId'),\n  Citation: dataValue('instance'),\n  DatasetYear: state => {\n    const date = state.data.today || state.data._submission_time;\n    const year = Number(date.trim().split('-')[0]);\n    const formName = dataValue('formName')(state);\n    const yearToReturn = year;\n    if (year <= 2010) yearToReturn = Number(formName.trim().split(' ').at(-1));\n    console.log(yearToReturn);\n    return yearToReturn;\n    // const formName = dataValue('formName')(state);\n    // if (formName === 'BNS Cross River 2017-2020') {\n    return state.data.body.today.split('-')[0];\n    // }\n    //const year = dataValue('body.today');\n    //console.log(year);\n    return new Date().getFullYear(); // Here we don't want the date of today we want the year of the value today\n    //console.log(Date(year).getFullYear());\n  },\n  LastSubmissionTime: dataValue('_submission_time'),\n  LastCheckedTime: dataValue('_submission_time'),\n  LastUpdateTime: new Date().toISOString(),\n  KoboManaged: true,\n  Tags: dataValue('_tags'),\n});\n",
          "adaptor": "@openfn/language-mssql@2.6.1",
          "project_credential_id": "b5fa2c78-00ab-4795-92d0-1078e7789aaa"
        },
        "BNS-2C-NRGT---Historical-Version": {
          "id": "856aa8dd-0b53-4dbd-8af8-972315bc5879",
          "name": "BNS-2C NRGT - Historical Version",
          "body": "// NOTE: This data cleaning operation returns state, modified as needed.\nalterState(state => {\n  try {\n    const { body, formName, instance } = state.data;\n    const { _submission_time, _id, _xform_id_string } = body;\n    let cleanedSubmission = {};\n\n    for (const key in body) {\n      switch (body[key]) {\n        case 'yes':\n          cleanedSubmission[key] = 1;\n          break;\n\n        case 'no':\n          cleanedSubmission[key] = 0;\n          break;\n\n        default:\n          cleanedSubmission[key] = body[key];\n          break;\n      }\n    }\n\n    state.landscapeMap = {\n      tns: 'ndoki',\n      mamabay: 'makira',\n      mtkb: 'kahuzi',\n      lactele: 'lac_tele',\n    };\n\n    cleanedSubmission.durableUUID = `${_submission_time}-${_xform_id_string}-${_id}`;\n    cleanedSubmission.datasetId = `${formName}-${_xform_id_string}`;\n    cleanedSubmission.instance = instance;\n    state.data = cleanedSubmission;\n    return state;\n  } catch (error) {\n    state.connection.close();\n    throw error;\n  }\n});\n\nupsert('WCSPROGRAMS_KoboNrgtNrgtanswer', 'AnswerId', {\n  DatasetUuidId: dataValue('datasetId'),\n  AnswerId: dataValue('_id'),\n  Landscape: state => {\n    var landscape = dataValue('landscape')(state);\n    return state.landscapeMap[landscape] || landscape;\n  },\n  GovGroup: dataValue('gov_group'),\n  Jurisdiction: dataValue('jurisdiction'),\n  Objective: dataValue('objective'),\n  Members: dataValue('members'),\n  Women: dataValue('women'),\n  LastUpdate: new Date().toISOString(),\n});\n\nupsert('WCSPROGRAMS_KoboNrgtNrgtanswergs', 'AnswerId', {\n  DatasetUuidId: dataValue('datasetId'),\n  Id: dataValue('_id'),\n  AnswerId: dataValue('_id'),\n  SurveyDate: dataValue('today'),\n  Code: dataValue('code'),\n  Gender: dataValue('gender'),\n  Member: dataValue('member'),\n  Legitimacy: dataValue('legitimacy'),\n  Accountability: dataValue('accountability'),\n  Transparency: dataValue('transparency'),\n  Participation: dataValue('participation'),\n  Fairness: dataValue('fairness'),\n  KnowledgeSkills: dataValue('knowledge_skills'),\n  Resources: dataValue('resources'),\n  InstutionalFramework: dataValue('institutional_framework'),\n  Motivation: dataValue('motivation'),\n  EnactDecision: dataValue('enact_decision'),\n  HeldAccountable: dataValue('held_accountable'),\n  Diversity: dataValue('diversity'),\n  LastUpdate: new Date().toISOString(),\n});\n\nupsert('WCSPROGRAMS_KoboData', 'DatasetUuidId', {\n  //AnswerId: dataValue('_id'),\n  DatasetName: state.data.formName,\n  DatasetOwner: state.data.formOwner,\n  DatasetUuidId: dataValue('datasetId'),\n  Citation: dataValue('instance'),\n  DatasetYear: new Date().getFullYear(),\n  LastSubmissionTime: dataValue('_submission_time'),\n  LastCheckedTime: dataValue('_submission_time'),\n  LastUpdateTime: new Date().toISOString(),\n  KoboManaged: true,\n  Tags: dataValue('_tags'),\n});\n",
          "adaptor": "@openfn/language-mssql@3.0.0",
          "project_credential_id": "b5fa2c78-00ab-4795-92d0-1078e7789aaa"
        },
        "BNS-2D-NRGT-2019": {
          "id": "c0cef1cd-ad7c-4aeb-8f70-dc6f7f0b4658",
          "name": "BNS-2D NRGT 2019",
          "body": "// NOTE: This data cleaning operation returns state, modified as needed.\nalterState(state => {\n  try {\n    const { body, formName, instance } = state.data;\n    const { _submission_time, _id, _xform_id_string } = body;\n    let cleanedSubmission = {};\n\n    for (const key in body) {\n      switch (body[key]) {\n        case 'yes':\n          cleanedSubmission[key] = 1;\n          break;\n\n        case 'no':\n          cleanedSubmission[key] = 0;\n          break;\n\n        default:\n          cleanedSubmission[key] = body[key];\n          break;\n      }\n    }\n\n    state.landscapeMap = {\n      tns: 'ndoki',\n      mamabay: 'makira',\n      mtkb: 'kahuzi',\n    };\n\n    cleanedSubmission.durableUUID = `${_submission_time}-${_xform_id_string}-${_id}`;\n    cleanedSubmission.datasetId = `${formName}-${_xform_id_string}`;\n    cleanedSubmission.instance = instance;\n    state.data = cleanedSubmission;\n    return state;\n  } catch (error) {\n    state.connection.close();\n    throw error;\n  }\n});\n\nupsert('WCSPROGRAMS_KoboNrgtNrgtanswer', 'AnswerId', {\n  DatasetUuidId: dataValue('datasetId'),\n  AnswerId: dataValue('_id'),\n  Landscape: state => {\n    var landscape = dataValue('landscape')(state);\n    return state.landscapeMap[landscape] || landscape;\n  },\n  Surveyor: dataValue('surveyor'),\n  GovGroup: dataValue('gov_group'),\n  SurveyDate: state => {\n    const date = state.data.today || state.data._submission_time\n    if (Number(date.split('-')[0]) >= 2014 ) {\n      return date\n    } \n    return 2019 \n    // If the time/date is not properly set on the device used to collect the data, the year of \"today\" will be 2000. \n    // With the code above we are replacing any 2000 by 2019:\n  },\n  LastUpdate: new Date().toISOString(),\n});\nupsert('WCSPROGRAMS_KoboNrgtNrgtanswergs', 'AnswerId', {\n  // upsert('WCSPROGRAMS_KoboNrgtNrgtanswergs', 'DatasetUuidId', {\n  DatasetUuidId: dataValue('datasetId'),\n  Id: dataValue('_id'),\n  AnswerId: dataValue('_id'),\n  SurveyDate: state => {\n    const date = state.data.today || state.data._submission_time\n    if (Number(date.split('-')[0]) >= 2014 ) {\n      return date\n    } \n    return 2019\n    // If the time/date is not properly set on the device used to collect the data, the year of \"today\" will be 2000. \n    // With the code above we are replacing any 2000 by 2019:\n  },\n  Gender: dataValue('gender'),\n  Member: dataValue('member'),\n  Objective: dataValue('objective'),\n  Legitimacy: dataValue('legitimacy'),\n  Accountability: dataValue('accountability'),\n  Transparency: dataValue('transparency'),\n  Participation: dataValue('participation'),\n  Fairness: dataValue('fairness'),\n  Diversity: dataValue('diversity'),\n  KnowledgeSkills: dataValue('knowledge_skills'),\n  Resources: dataValue('resources'),\n  InstutionalFramework: dataValue('framework'),\n  Motivation: dataValue('motivation'),\n  Power: dataValue('power'),\n  LastUpdate: new Date().toISOString(),\n});\n\nupsert('WCSPROGRAMS_KoboData', 'DatasetUuidId', {\n  //AnswerId: dataValue('_id'),\n  DatasetName: state.data.formName,\n  DatasetOwner: state.data.formOwner,\n  DatasetUuidId: dataValue('datasetId'),\n  Citation: dataValue('instance'),\n  DatasetYear: new Date().getFullYear(),\n  LastSubmissionTime: dataValue('_submission_time'),\n  LastCheckedTime: dataValue('_submission_time'),\n  LastUpdateTime: new Date().toISOString(),\n  KoboManaged: true,\n  Tags: dataValue('_tags'),\n});\n",
          "adaptor": "@openfn/language-mssql@3.0.0",
          "project_credential_id": "b5fa2c78-00ab-4795-92d0-1078e7789aaa"
        },
        "BNS-2E-NRGT---Historical-Version-2-2022": {
          "id": "55d15411-6a56-4614-8e25-f314f3381334",
          "name": "BNS-2E NRGT - Historical Version 2 2022",
          "body": "fn(state => {\n  try {\n    const { body, formName, instance } = state.data;\n    const { _submission_time, _id, _xform_id_string, group_scores } = body;\n    let cleanedSubmission = {};\n\n    for (const key in body) {\n      switch (body[key]) {\n        case 'yes':\n          cleanedSubmission[key] = 1;\n          break;\n\n        case 'no':\n          cleanedSubmission[key] = 0;\n          break;\n\n        default:\n          cleanedSubmission[key] = body[key];\n          break;\n      }\n    }\n\n    state.landscapeMap = {\n      tns: 'ndoki',\n      mamabay: 'makira',\n      mtkb: 'kahuzi',\n      lactele: 'lac_tele',\n    };\n\n    cleanedSubmission.durableUUID = `${_submission_time}-${_xform_id_string}-${_id}`;\n    cleanedSubmission.datasetId = `${formName}-${_xform_id_string}`;\n    cleanedSubmission.instance = instance;\n    cleanedSubmission.group_scores = group_scores;\n    \n    state.data = cleanedSubmission;\n\n    return state;\n  } catch (error) {\n    state.connection.close();\n    throw error;\n  }\n});\n\n\nupsert('WCSPROGRAMS_KoboNrgtNrgtanswer', 'AnswerId', {\n  DatasetUuidId: dataValue('datasetId'),\n  AnswerId: dataValue('_id'),\n  Landscape: state => {\n    var landscape = dataValue('landscape')(state);\n    return state.landscapeMap[landscape] || landscape;\n  },\n  GovGroup: dataValue('gov_group'),\n  Jurisdiction: dataValue('jurisdiction'),\n  Objective: dataValue('objective'),\n  Members: dataValue('members'),\n  Women: dataValue('women'),\n  LastUpdate: new Date().toISOString(),\n});\n\n/*\nupsert('WCSPROGRAMS_KoboNrgtNrgtanswergs', 'AnswerId', {\n  DatasetUuidId: dataValue('datasetId'),\n  Id: dataValue('_id'),\n  AnswerId: dataValue('_id'),\n  SurveyDate: dataValue('today'),\n  Code: dataValue('code'),\n  Gender: dataValue('gender'),\n  Member: dataValue('member'),\n  Legitimacy: dataValue('legitimacy'),\n  Accountability: dataValue('accountability'),\n  Transparency: dataValue('transparency'),\n  Participation: dataValue('participation'),\n  Fairness: dataValue('fairness'),\n  KnowledgeSkills: dataValue('knowledge_skills'),\n  Resources: dataValue('resources'),\n  InstutionalFramework: dataValue('institutional_framework'),\n  Motivation: dataValue('motivation'),\n  EnactDecision: dataValue('enact_decision'),\n  HeldAccountable: dataValue('held_accountable'),\n  Diversity: dataValue('diversity'),\n  LastUpdate: new Date().toISOString(),\n});\n*/\n\nupsertMany(\n  'WCSPROGRAMS_KoboNrgtNrgtanswergs', \n  'AnswerId', \n  state => state.data.group_scores.map(x => ({\n      AnswerId: state.data._id,\n      Id: state.data._id,\n      DatasetUuidId: state.data.datasetId,\n      Accountability: x[\"group_scores/accountability\"],\n      Code: x[\"group_scores/code\"],\n      Diversity: x[\"group_scores/diversity\"],\n      EnactDecision: x[\"group_scores/enact_decision\"],\n      Fairness: x[\"group_scores/fairness\"],\n      Gender: x[\"group_scores/gender\"],\n      HeldAccountable: x[\"group_scores/held_accountable\"],\n      InstutionalFramework: x[\"group_scores/institutional_framework\"],\n      KnowledgeSkills: x[\"group_scores/knowledge_skills\"],\n      Legitimacy: x[\"group_scores/legitimacy\"],\n      Member: (x[\"group_scores/member\"] === \"yes\"),\n      Motivation: x[\"group_scores/motivation\"],\n      Participation: x[\"group_scores/participation\"],\n      Resources: x[\"group_scores/resources\"],\n      SurveyDate: x[\"group_scores/survey_date\"],\n      Transparency: x[\"group_scores/transparency\"],\n      LastUpdate: new Date().toISOString()\n    }))\n);\n\n\nupsert('WCSPROGRAMS_KoboData', 'DatasetUuidId', {\n  DatasetName: state.data.formName,\n  DatasetOwner: state.data.formOwner,\n  DatasetUuidId: dataValue('datasetId'),\n  Citation: dataValue('instance'),\n  DatasetYear: new Date().getFullYear(),\n  LastSubmissionTime: dataValue('_submission_time'),\n  LastCheckedTime: dataValue('_submission_time'),\n  LastUpdateTime: new Date().toISOString(),\n  KoboManaged: true,\n  Tags: dataValue('_tags'),\n});\n",
          "adaptor": "@openfn/language-mssql@3.0.0",
          "project_credential_id": "b5fa2c78-00ab-4795-92d0-1078e7789aaa"
        }
      },
      "edges": {
        "webhook->Triage-jobs": {
          "enabled": true,
          "id": "b758386e-7c93-44dc-8393-cdea13e31c83",
          "target_job_id": "65e96922-0db6-4823-88ea-64601641c902",
          "source_trigger_id": "b3f86593-f37e-4139-80b8-852b9d3c49f4",
          "condition_type": "always"
        },
        "Triage-jobs->BNS-2A-BNS-Price": {
          "enabled": true,
          "id": "a4d1312a-c209-497a-8e19-462feccddeb3",
          "target_job_id": "7280bfa9-2a67-4c6e-8a3a-f7f21bcb26ae",
          "source_job_id": "65e96922-0db6-4823-88ea-64601641c902",
          "condition_type": "js_expression",
          "condition_label": "BNS Price",
          "condition_expression": "state.data.form == \"bns_price\" && state.data.body.body.survey_type != \"practice\""
        },
        "Triage-jobs->BNS-2B-BNS-Survey": {
          "enabled": true,
          "id": "b541e65c-79a6-4214-88c6-653133d65210",
          "target_job_id": "196697f9-b581-4397-8487-280df2d47529",
          "source_job_id": "65e96922-0db6-4823-88ea-64601641c902",
          "condition_type": "js_expression",
          "condition_label": "BNS Survey",
          "condition_expression": "state.data.body.form == \"bns_survey\" && state.data.body.body.survey_type != \"practice\""
        },
        "Triage-jobs->BNS-2C-NRGT---Historical-Version": {
          "enabled": true,
          "id": "f19030bd-1907-409b-84c4-9d0f41b358f4",
          "target_job_id": "856aa8dd-0b53-4dbd-8af8-972315bc5879",
          "source_job_id": "65e96922-0db6-4823-88ea-64601641c902",
          "condition_type": "js_expression",
          "condition_label": "NRGT Historical",
          "condition_expression": "state.data.form == \"nrgt_historical\" && state.data.formName != \"NRGT Kahuzi Biega 2019\""
        },
        "Triage-jobs->BNS-2D-NRGT-2019": {
          "enabled": true,
          "id": "8d13c9cc-6efd-436b-8d4f-f655e89283cc",
          "target_job_id": "c0cef1cd-ad7c-4aeb-8f70-dc6f7f0b4658",
          "source_job_id": "65e96922-0db6-4823-88ea-64601641c902",
          "condition_type": "js_expression",
          "condition_label": "NRGT Current",
          "condition_expression": "state.data.form == \"nrgt_current\"  && state.data.body.body.survey_type != \"practice\""
        },
        "Triage-jobs->BNS-2E-NRGT---Historical-Version-2-2022": {
          "enabled": true,
          "id": "07ac5d9c-cc2e-480a-82a2-1cf46d4bad22",
          "target_job_id": "55d15411-6a56-4614-8e25-f314f3381334",
          "source_job_id": "65e96922-0db6-4823-88ea-64601641c902",
          "condition_type": "js_expression",
          "condition_label": "NGRT Historical",
          "condition_expression": "state.data.form == \"nrgt_historical\" && state.data.formName == \"NRGT Kahuzi Biega 2019\""
        }
      }
    },
    "3.-Get-all-BNS-Kobo-forms-on-demand": {
      "id": "c0afba46-75e0-4b7e-a202-1b2484fefd98",
      "name": "3. Get all BNS Kobo forms on-demand",
      "inserted_at": "2025-03-18T09:48:24.435836Z",
      "lock_version": 8,
      "triggers": {
        "cron": {
          "enabled": false,
          "id": "b4e57060-a0db-4c90-8519-1e7e36c576fc",
          "type": "cron",
          "cron_expression": "0 22 1 * *"
        }
      },
      "jobs": {
        "BNS-3-Get-all-Kobo-forms-on-demand": {
          "id": "1413d493-03a1-498a-88c9-662adf2a7e94",
          "name": "BNS-3 Get all Kobo forms on-demand",
          "body": "//== Run this job on-demand to get ALL submissions for any Kobo form ==//\n\nalterState(state => {\n  console.log(`Started at: ${new Date().toISOString()}`);\n  state.submissions = [];\n  state.data = {\n    surveys: [\n      //** Specify new forms to fetch here **//\n      //** Tag options: bns_survey, bns_price, nrgt_current, nrgt_historical  **//\n      // Historical  forms to migrate:\n      //Make sure the tag matches the Trigger of the related Job\n\n      //******* OPENFN TEST FORMS ******///\n      // { id: 'aijj9FSpuCzMTRnMPGike8', tag: 'nrgt_historical', name: 'NRGT Makira 2017 - Test OpenFn', owner: 'bns' }, // TEST\n      // { id: 'av4hQ37rMgwFoh9ogjeyKh', tag: 'nrgt_current', name: 'NRGT 2019 - Test OpenFn', owner: 'bns' }, // TEST\n      // { id: 'azrSYMFpj3M8jdFkApT3o6/', tag: 'bns_price', name: 'BNS Prix Ndoki 2019 - Test OpenFn', owner: 'bns' }, // TEST\n      { id: 'aUrUbD6C9hB3y8XjfQ9CLc', tag: 'bns_survey', name: 'BNS Ndoki 2019 - OpenFn Test', owner: 'bns' }, // TEST\n      //****** Ongoing Forms to Rerun ****//\n      //TODO: need to uncomment\n      // {id: 'aJn5HK9fFFQt2BMUo5GW2s', tag: 'bns_survey', name: 'BNS menages Lac Tele 2024', owner: 'wcs_lactele', instance: 'WCS Congo unpublished data 2024' },\n\n\n      //******* WCS HISTORICAL FORMS ******///\n\n  // BNS HH 2024\n  ////  { id: 'aEjwpqLhg4CQbPRuFQMCFj', tag: 'bns_survey', name: 'BNS household Yankari 2024', owner: 'wcs_yankari', instance: 'WCS Nigeria unpublished data 2024' }, // Added manually by DD on Aug 21, 2024\n     // { id: 'aGfcUnks7JLms4YCGbHgwX', tag: 'bns_survey', name: 'BNS intervention Cross River 2023', owner: 'cemogor', instance: 'C. Emogor, 2024' },// \n     // { id: 'aJrXKdPgXfwSnam5iwaRHq', tag: 'bns_survey', name: 'BNS Ciblage 4e cohorte 2024', owner: 'wcs_poultry', instance: 'A. M. Boucka, A. Nkounkou, WCS Congo unpublished data 2024' },// New landscape: NdokiPeriphery\n\n  // BNS Prices 2024\n  ////  { id: 'aKh9KWTrqwXsjVfHeJG9sL', tag: 'bns_price', name: 'BNS Prices Yankari 2024', owner: 'wcs_yankari', instance: 'WCS Nigeria unpublished data 2024' }, // Added manually by DD on Aug 21, 2024\n\n  // NRGT 2024\n  //{ id: 'aKYgSnUiLd8KkevPV2ty6e', tag: 'nrgt_current', name: 'NRGT NW Janvier 2024', owner: 'bemahafaly_wcs', instance: 'WCS Madagascar unpublished data 2024'}, \n\n\n  // BNS HH 2023\n     // { id: 'aNznavxK7BXXgtvLVY6wm2', tag: 'bns_survey', name: 'BNS household Crossriver 2023', owner: 'wcs_crossriver', instance: 'WCS Nigeria unpublished data 2023' }, \n     // { id: 'a5jucWV84nFeP3BeHtbRMU', tag: 'bns_survey', name: 'BNS Menage PNMD 2023', owner: 'wcs_paapnmd', instance: 'WCS Cameroon unpublished data 2023' }, \n     // { id: 'aJVZmRRfj442Li5F6r6M8y', tag: 'bns_survey', name: 'BNS ménage Kahuzi 2023', owner: 'wcs_mtkb', instance: 'WCS DRC unpublished data 2023' }, \n     // { id: 'aK3MS8ATY53KXsKCm7xzpY', tag: 'bns_survey', name: 'BNS Ituri : Enquête Ménages 2023', owner: 'wcs_ituri', instance: 'WCS DRC unpublished data 2023' }, \n     // { id: 'a9SgR3L9Vzn8CC5UPAa2ou', tag: 'bns_survey', name: 'BNS EPP 2e/3e cohortes 2023', owner: 'wcs_poultry', instance: 'WCS Congo unpublished data 2023' }, \n     // { id: 'aAGC9q7nwXPnVLP6bFNAEw', tag: 'bns_survey', name: 'BNS_Individual_Niassa_2023', owner: 'wcs_niassa', instance: 'WCS Niassa unpublished data 2023' }, \n      \n  // BNS Prices 2023\n     // { id: 'aQ5Q6iarRWtKp2dY2okbDe', tag: 'bns_price', name: 'BNS Prices Crossriver 2023',  owner: 'wcs_crossriver', instance: 'WCS Nigeria unpublished data 2023' }, \n     // { id: 'aKVvMRrvTTCc8j7d3EDh7a', tag: 'bns_price', name: 'BNS Prix PNMD 2023',  owner: 'wcs_paapnmd', instance: 'WCS Cameroon unpublished data 2023' }, \n     // { id: 'a4oeehbiGuXrEWK7rkUv82', tag: 'bns_price', name: 'BNS Prix Ituri 2023', owner: 'wcs_ituri', instance: 'WCS DRC unpublished data 2023' }, \n     // { id: 'aH2dvuU2G8wiVZQ3k4fiRE', tag: 'bns_price', name: 'BNS Prix Kabobo 2023', owner: 'wcs_pcbk', instance: 'WCS DRC unpublished data 2023' }, \n     // { id: 'a3kbAt2freW3q8Ht48V3q2', tag: 'bns_price', name: 'BNS Prix Kahuzi 2023', owner: 'wcs_mtkb', instance: 'WCS DRC unpublished data 2023' }, \n     // { id: 'aAKdquWgPSLjzB3UgGBcsW', tag: 'bns_price', name: 'BNS_Precos_Niassa_2023', owner: 'wcs_niassa', instance: 'WCS Niassa unpublished data 2023'}, \n  \n  // NRGT 2023\n     // { id: 'aqDKwe8AD3ykFeNEDuLSnv', tag: 'nrgt_current', name: 'Nosy Be NRGT 2023', owner: 'wcs_library', instance: 'WCS Madagascar unpublished data 2023' }, \n     // { id: 'aDEEXL9fXQhZXpdaKPnrcJ', tag: 'nrgt_current', name: 'NRGT_Makira_2023_revisé', owner: 'wcs_mamabaie', instance: 'WCS Madagascar unpublished data 2023'},      // { id: 'aqDKwe8AD3ykFeNEDuLSnv',  tag: 'nrgt_current', name: 'Nosy Be NRGT 2023', owner: 'wcs_library', instance: 'WCS Madagascar unpublished data 2023' }, \n     // { id: 'a33XvMuPQLpeygLURuNUBP', tag: 'nrgt_current', name: 'NRGT SWM 2023', owner: 'wcs_ndoki', instance: 'WCS Congo unpublished data 2023' }, //May 2023\n     // { id: 'a8KBiBL44hEpNfkS4RmxeN', tag: 'nrgt_current', name: 'NRGT_Niassa_2023', owner: 'wcs_niassa', instance: 'WCS Niassa unpublished data 2023' }, \n          \n  // BNS HH 2022\n     // { id: 'aXf5DPR25YsB8f3mXS7LDh', tag: 'bns_survey', name: 'BNS household Crossriver 2022', owner: 'wcs_crossriver', instance: 'WCS Cross River unpublished data 2022'}, \n     // { id: 'aH2cMdEFcpwjmtBpz7TnyH', tag: 'bns_survey', name: 'BNS_Nosy Be_2022', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, WCS Madagascar 2022'},\n     // { id: 'aGT9DSs6zf6q54okHR6UxY', tag: 'bns_survey', name: 'BNS_ABS_2022', owner: 'wcs_antongil', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, WCS Madagascar 2022'}, \n     // { id: 'aGKL3jhaGpvfCP7ekPNyr4', tag: 'bns_survey', name: 'BNS_Ankarea/Ankivonjy_2022', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, WCS Madagascar 2022'}, \n     // { id: 'a5MyeTAhZ5WHadabcNVMcU', tag: 'bns_survey', name: 'BNS_Soariake_2022_FINAL', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, WCS Madagascar 2022' }, \n     // { id: 'aXc8nMwPbqrKMDqrBPu4LW', tag: 'bns_survey', name: 'hunter BNS', owner: 'cemogor', instance: 'C. Emogor unpublished data 2022' },  // synced Jan 2023\n     // { id: 'aRnpV9xNVcbqLPbmoKn9sR', tag: 'bns_survey', name: 'BNS NDOKI 2022', owner: 'wcs_ndoki', instance: 'SWM Ndoki unpublished data 2022' }, // synced 18 March 2022\n     // { id: 'aF9PF9YUE5yBVsUvWUr2pV', tag: 'bns_survey', name: 'BNS_Individual_Niassa_2022', owner: 'wcs_niassa', instance: 'Niassa Special Reserve unpublished data 2022' }, // synced 18 April 2022 \n     // { id: 'aDvmfKGNq6H2yhcMTbP5tB', tag: 'bns_survey', name: 'BNS ménage Kahuzi 2022', owner: 'wcs_mtkb', instance: 'Kahuzi Biega National Park unpublished data 2022' }, //resynced August 2022\n     // { id: 'aLJLeHSYsN7DCLQmmYJR8w', tag: 'bns_survey', name: 'BNS EPP Poulet 2022-2023', owner: 'wcs_poultry', instance: 'WCS Congo - Environmental Partnership Program, Livelihood diversification and poultry production - unpublished data 2022' }, // Synced Sept 22, 2022\n      \n  // BNS Prices 2022\n     // { id: 'aGBARLZxAd9zYZ37S8DZwj', tag: 'bns_price', name: 'BNS Prices Crossriver 2022', owner: 'wcs_crossriver', instance: 'WCS Cross River unpublished data 2022' }, \n     // { id: 'aBEqtVJto8GjzfgBzJBAis', tag: 'bns_price', name: 'Prix_BNS_Nosy Be_2022', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, WCS Madagascar 2022'}, \n     // { id: 'aLa2L2dNrkhceAsp2AWD4A', tag: 'bns_price', name: 'Prix_BNS_ABS_2022', owner: 'wcs_antongil', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, WCS Madagascar 2022'}, \n     // { id: 'aSuJPLgRj4vTA8gMmDyKJK', tag: 'bns_price', name: 'Prix_BNS_Ankarea/Ankivony_2022', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, WCS Madagascar 2022'}, \n     // { id: 'a4pMJRa3jn264kvVSv3vm7', tag: 'bns_price', name: 'Prix_BNS_Soariake_2022', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, WCS Madagascar 2022' }, \n     // { id: 'aKTbms2Fw6fa2XS3rKMwxv', tag: 'bns_price', name: 'BNS Ndoki Prix 2022', owner: 'wcs_ndoki', instance: 'SWM Ndoki unpublished data 2022' }, // synced 18 March 2022\n     // { id: 'aZgCs6vmSVdDMmYWoW9hfe', tag: 'bns_price', name: 'BNS_Precos_Niassa_2022', owner: 'wcs_niassa', instance: 'Niassa Special Reserve unpublished data 2022' }, // synced 18 April 2022 \n     // { id: 'aaCTf3buZnjjQDu9wmyACF', tag: 'bns_price', name: 'BNS Prix Kahuzi 2022', owner: 'wcs_mtkb', instance: 'Kahuzi Biega National Park unpublished data 2022' }, //resynced August 2022 \n   \n  // NRGT 2022\n     // { id: 'amaXEkoh4eNcKyjjys8jGG', tag: 'nrgt_current', name: 'NRGT Crossriver 2022', owner: 'wcs_crossriver', instance: 'WCS Cross River unpublished data 2022'}, \n     // { id: 'aXFnVax8EugC22oRJAnWoV', tag: 'nrgt_current', name: 'NRGT Kahuzi 2022', owner: 'wcs_mtkb', instance: 'A. Twendilonge, F. Kavuba, WCS Kahuzi unpublished data 2022' }, // resynced 2nd Nov 2022\n     // { id: 'aBfgRPninKvZEtfpMMqchu', tag: 'nrgt_current', name: 'NRGT Ituri 2022', owner: 'wcs_ituri', instance: 'B. Ikati, D. Bilua, S. Ahasa, WCS Ituri unpublished data 2022' }, // synced Oct 2022\n     // { id: 'aMBGNEH6BzFVjxSZ2zHegc', tag: 'nrgt_current', name: 'NRGT_Niassa_2022', owner: 'wcs_niassa', instance: 'Niassa Special Reserve unpublished data 2022'}, // synced Sept 21, 2022,\n      \n  // BNS HH 2021 \n     // { id: 'aEMeCB6j4BfUVDF4FrGuKw', tag: 'bns_survey', name: 'Conso+BNS Bismarck 2021', owner: 'wcs_bismarck', instance: 'WCS Bismarck unpublished data 2021'  }, // synced August 2022\n     // { id: 'aSgFKK6Ufq7a4qXDe5yshg', tag: 'bns_survey', name: 'BNS Ituri : Enquête Ménages 2021', owner: 'wcs_ituri', instance: 'WCS Ituri unpublished data 2021'  }, // synced Feb 24 2022\n     // { id: 'aokQtdTGTnLW6omXRrf4ss', tag: 'bns_survey', name: 'BNS menages Lac Tele 2021', owner: 'wcs_lactele', instance: 'G. Bondeko, O. Mbala, L. Molouagna, R. Silaho. , WCS Lac Télé unpublished data 2021'  }, // synced August 2022\n     // { id: 'aLe9gkcRNXbtNHF6m8tNn8', tag: 'bns_survey', name: 'Socio-economic survey-EU', owner: 'wcs_ug_eu', instance: 'M. Nyago, P. Hatanga, H. Musabende, S. Nampindo, S. Amoko, M. Busiinge, WCS Uganda unpublished data 2021'  }, // synced Feb 24 2022\n     // { id: 'aVLz2FxFcw99cv89xNY46K', tag: 'bns_survey', name: 'BNS Makira 2021', owner: 'wcs_mamabaie', instance: 'C. Spira, C. Milina, WCS Madagascar unpublished data 2021' }, // synced Feb 24 2022\n\n  // BNS Prices 2021\n     // { id: 'atKMA7EXQWRKYTUVAi3JgZ', tag: 'bns_price', name: 'BNS Price Bismarck 2021', owner: 'wcs_bismarck', instance: 'WCS Bismarck unpublished data 2021'}, // synced August 2023\n     // { id: 'arwWLVDnQkJkNV4HtzgmeX', tag: 'bns_price', name: 'BNS Prix Ituri 2021', owner: 'wcs_ituri', instance: 'WCS Ituri unpublished data 2021'}, // synced Feb 24 2022\n     // { id: 'aKZCAWsMgUkJDcYKv2Dern', tag: 'bns_price', name: 'BNS Prix Lac Télé 2021', owner: 'wcs_lactele', instance: 'G. Bondeko, O. Mbala, L. Molouagna, R. Silaho. , WCS Lac Télé unpublished data 2021'},//rsynced Feb 24 2022\n     // { id: 'aVcvLwLaG9ZCnQ9b7ACc2h', tag: 'bns_price', name: 'Prix Makira 2021', owner: 'wcs_mamabaie', instance: 'C. Spira, C. Milina, WCS Madagascar unpublished data 2021'}, // synced Feb 24 2022\n\n  // NRGT 2021\n     // { id: 'atB3SwmsxjhoYppdTiCxEw', tag: 'nrgt_current', name: 'NRGT Makira 2021', owner: 'wcs_mamabaie', instance:'WCS Madagascar unpublished data 2021'}, // synced Sept 23, 2022\n\n  // BNS HH 2020\n     // { id: 'aGUVyBVFK8eYiRZhKanq3V', tag: 'bns_survey', name: 'BNS Makira 2020 - cacao', owner: 'wcs_mamabaie', instance: 'WCS Madagascar unpublished data 2020' }, \n     // { id: 'ad7S4hPBN7qM4Ac3mpEdwZ', tag: 'bns_survey', name: 'BNS_Nosy Be_2020', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, C. Spira, WCS Madagascar unpublished data 2020' }, // resynced December 2021\n     // { id: 'atyo55YdBdfxzXiaBdrbvr', tag: 'bns_survey', name: 'BNS Ndoki Parc 2020', owner: 'wcs_ndoki', instance: 'Y. Londza & Nouabalé-Ndoki National Park team' }, // resynced December 2021\n     // { id: 'ar9wXnLW2sdaamGgJsUrjP', tag: 'bns_survey', name: 'Socio-Eco Uganda 2020', owner: 'wcs_uganda_carbon', instance: 'M. Nyago, H. Musabende & WCS Uganda Carbon team'}, // resynced December 2021\n     // { id: 'amD3cUsR4Jurj3ZSUyQdBH', tag: 'bns_survey', name: 'BNS Cross River 2017 - 2020 ', owner: 'wcs_crossriver', instance: 'I. Imong, J. Ntui, O. Okagbare, S. Ova, L. Nkonyu, WCS Nigeria unpublished data 2017-2020'}, // resynced December 2021\n     // { id: 'aPH34CUc7zGbzeowRALdTu', tag: 'bns_survey', name: 'Basic Necessity Survey Cross River', owner: 'cemogor', instance: 'C. Emogor unpublished data 2020'}, // Synced Sept 22, 2022\n      \n  // BNS Prices 2020\n     // { id: 'aj67aaDZa52oLBFPVGWWwu', tag: 'bns_price', name: 'Prix_BNS_Nosy Be_2020', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, C. Spira, WCS Madagascar unpublished data 2020' }, // resynced December 2021 \n     // { id: 'aTRKQW2b8TJGxF7DVPfjFv', tag: 'bns_price', name: 'BNS Ndoki Prix 2020', owner: 'wcs_ndoki', instance: 'Y. Londza & Nouabalé-Ndoki National Park team' }, // resynced December 2021\n\n  // NRGT 2020\n     // { id: 'axSXT4r6TkLxnr3CBggmzg', tag: 'nrgt_current', name: 'NRGT Ndoki 2020', owner: 'wcs_ndoki', instance: 'Y. Londza, WCS Congo unpublished data 2020' }, // synced Sept 07, 2021\n      \n  // BNS HH 2019\n     // { id: 'ahz5DN45juUzp7eUfGS5QA', tag: 'bns_survey', name: 'BNS SWM Ndoki 2019', owner: 'wcs_ndoki', instance: 'G. Mavah, B. Avelino, G. Ngohouani, R. Mouanda, F. Mossoula, B. Ngampamou' }, // resynced December 2021\n     // { id: 'acK4WZ2ueqk8NvUdwctxz8', tag: 'bns_survey', name: 'BNS_Soariake_2019', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, C. Spira, WCS Madagascar unpublished data 2019' }, // resynced December 2021\n     // { id: 'auPGpyWbn4PhTuWFBfKYES', tag: 'bns_survey', name: 'BNS_ABS_2019_FINAL', owner: 'wcs_antongil', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, C. Spira, WCS Madagascar unpublished data 2019' }, // resynced December 2021\n     // { id: 'azepksQ62i8vETEzUfz8jj', tag: 'bns_survey', name: 'BNS_Ankarea/Ankivonjy_2019', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, C. Spira, WCS Madagascar unpublished data 2019' }, // resynced August 2022\n     // { id: 'ahz5DN45juUzp7eUfGS5QA', tag: 'bns_survey', name: 'BNS Ndoki 2019', owner: 'wcs_ndoki', instance: 'G. Mavah, B. Avelino, G. Ngohouani, R. Mouanda, F. Mossoula, B. Ngampamou, WCS Congo unpublished data 2019' }, // resynced December 2021\n     // { id: 'aCShrrKNApccvaAPzxzbxK', tag: 'bns_survey', name: 'BNS ménage Kahuzi 2019', owner: 'wcs_mtkb', instance: 'F. Kavuba, A. Twendilonge, R. Cito, WCS RDC unpublished data 2019' }, // resynced December 2021\n     // { id: 'arJkDGmkhhCiJ2eYwRcCit', tag: 'bns_survey', name: 'BNS Makira 2019', owner: 'wcs_mamabay', instance: 'C. Spira, N. Dokolahy, J. Ranariniaina, M. Cournarie, L. Andriamampianina,  D. Detoeuf, WCS Madagascar unpublished data 2019' }, // resynced December 2021\n     // { id: 'aFQWAYHXXfh8i2cmXw9BFi', tag: 'bns_survey', name: 'BNS Ituri: Enquête Ménages 2019', owner: 'wcs_ituri', instance: 'B. Ntumba, A. Ohole, B. Ikati, T. Muller, WCS RDC unpublished data 2019' }, // resynced December 2021\n\n  // BNS Prices 2019\n     // { id: 'aq5r9cKQYBRDT9SBqYanUP', tag: 'bns_price', name: 'BNS SWM Prix Ndoki 2019', owner: 'wcs_ndoki', citation: \"G. Mavah, B. Avelino, G. Ngohouani, R. Mouanda, F. Mossoula, B. Ngampamou\" }, // resynced January 2022\n     // { id: 'aApqbThMPaMJhczK2QKVLD', tag: 'bns_price', name: 'BNS Prix Kahuzi 2019', owner: 'wcs_mtkb', instance: 'F. Kavuba, A. Twendilonge, R. Cito, WCS RDC unpublished data 2019' }, // resynced January 2022\n     // { id: 'aJZxvpgS73vJu4NUxTtvwJ', tag: 'bns_price', name: 'Prix_BNS_ABS_2019', owner: 'wcs_antongil', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, C. Spira, WCS Madagascar unpublished data 2019' }, // resynced January 2022\n     // { id: 'av3SpGmYTBP9A6dLMbzhZR', tag: 'bns_price', name: 'Prix_BNS_Soariake_2019', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, C. Spira, WCS Madagascar unpublished data 2019' }, // resynced January 2022\n     // { id: 'awAV28ebngN7GTV2nqmyKU', tag: 'bns_price', name: 'Price Makira 2019', owner: 'wcs_mamabaie', instance: 'C. Spira, N. Dokolahy, J. Ranariniaina, M. Cournarie, L. Andriamampianina,  D. Detoeuf, WCS Madagascar unpublished data 2019'  }, // resynced January 2022\n     // { id: 'awQmCEf63g5KN2G4kcBWrc', tag: 'bns_price', name: 'BNS Prix Ituri 2019', owner: 'wcs_ituri', instance: 'B. Ntumba, A. Ohole, B. Ikati, T. Muller, WCS RDC unpublished data 2019' }, // resynced January 2022\n     // { id: 'a2bwTreEbymbWD3JGJ2qXT', tag: 'bns_price', name: 'Prix_BNS_Ankarea/Ankivony_2019', owner: 'wcs_soariake', instance: 'S. Rakotoharimalala, R. Ranaivoson, C. Razafindrakoto, D. Detoeuf, C. Spira, WCS Madagascar unpublished data 2019' }, // resynced August 2022\n\n  // NRGT 2019\n     // { id: 'aZZV4KikgRKz79LqqQR5Ma', tag: 'nrgt_current', name: 'NRGT Ituri 2019', owner: 'wcs_ituri', instance: 'B. Ntumba, A. Ohole, B. Ikati, T. Muller, WCS RDC unpublished data 2019' }, // resynced January 2022\n     // { id: 'anAcQ9on4inNnmtqFVpabh', tag: 'nrgt_historical', name: 'NRGT Kahuzi Biega 2019', owner: 'wcs_mtkb', instance:'F. Kavuba, A. Twendilonge, R. Cito, WCS RDC unpublished data 2019'}, // resynced Feb 2022\n     // { id: 'ajDeQVDrz2AZxvxLLWjiBE', tag: 'nrgt_current', name: 'NRGT Makira 2019', owner: 'wcs_mamabaie', instance:'C. Spira, N. Dokolahy, J. Ranariniaina, M. Cournarie, L. Andriamampianina,  D. Detoeuf, WCS Madagascar unpublished data 2019'}, // resynced January 2022\n     // { id: 'aotHau7krdjj2NFBNAJpZC', tag: 'nrgt_current', name: 'NRGT_ABS_2019_V1', owner: 'nrgtmada', instance:'WCS Madagascar unpublished data 2019'}, \n     // { id: 'a8yPcus6ggWBXK5iK8LpC7', tag: 'nrgt_current', name: 'NRGT_SW_2019_V1', owner: 'rchristelle', instance:'WCS Madagascar unpublished data 2019'}, \n     // { id: 'aGYzFZPUFfvCvnKG8gyfjG', tag: 'nrgt_current', name: 'NRGT_NW_2019_V1', owner: 'nrgtmada', instance:'WCS Madagascar unpublished data 2019'}, \n\n  // BNS HH 2018\n     // { id: 'aQbjGLfvPTEUjdTmsdTu46', tag: 'bns_survey', name: 'BNS Ndoki 2018', owner: 'wcs_ndoki', instance: 'Y. Londza, F. Sellat, D. Detoeuf, WCS Congo unpublished data 2018' }, // resynced January 2022\n\n  // BNS Prices 2018\n     // { id: 'ao52kp6BgLgooE3MRsdy4B', tag: 'bns_price', name: 'BNS Prix Ndoki 2018', owner: 'wcs_ndoki', instance: 'Y. Londza, F. Sellat, D. Detoeuf, WCS Congo unpublished data 2018'  }, //  resynced January 2022\n\n  // NRGT 2018\n     //  { id: 'apFFEwXk38TQ2SCkV99bFY', tag: 'nrgt_historical', name: 'NRGT Kahuzi Biega 2018', owner: 'wcs_mtkb', instance:'' }, // resynced Fec 2022\n     // { id: 'aLhFXhkmM4rZJvtqiSjChE', tag: 'nrgt_historical', name: 'NRGT Ndoki 2018', owner: 'wcs_ndoki', instance:'' }, // resynced January 2022\n     // { id: 'awR6CQTvEqiL9PYvMic7dE', tag: 'nrgt_historical', name: 'NRGT Bateke 2018', owner: 'wcs_bateke', instance:'' }, // resynced January 2022\n\n  // BNS HH 2017\n     // { id: 'aEypYtcfNGvDtpkSUPXrJN', tag: 'bns_survey', name: 'BNS ménage Kahuzi 2018-2019', owner: 'wcs_mtkb', instance: 'C. Spira, A. Kirkby, F. Kavuba, D. Detoeuf, A. Twendilonge, WCS RDC unpublished data 2017' }, // resynced August 2022\n     // { id: 'a9R68Er4oeDx6quZre2DM7', tag: 'bns_survey', name: 'BNS Makira 2017', owner: 'wcs_mamabaie', instance: 'M. Ravelona, WCS Madagascar unpublished data 2017' }, // resynced January 2022\n     // { id: 'auqBASwJMLvkqtAJnZ8SXx', tag: 'bns_survey', name: 'BNS Lac Télé 2017', owner: 'wcs_lactele', instance: 'G. Bondeko, N. Loundou, R. Mouanda, R. Mossaba, M. Boboto, D. Detoeuf, WCS Congo unpublished data 2017' }, // resynced January 2022\n     // { id: 'a2m5Hp4BoN956CBxfKHdJY', tag: 'bns_survey', name: 'BNS Ituri: Enquête Ménages 2017', owner: 'wcs_ituri', instance: 'M. Enduyi, A. Tsongo, J. Maneno, O. Angauko, A. Ohole, WCS RDC unpublished data 2017'}, // resynced January 2022\n     // { id: 'amD3cUsR4Jurj3ZSUyQdBH', tag: 'bns_survey', name: 'BNS Crossriver 2017', owner: 'wcs_crossriver', instance: 'I. Imong, J. Ntui, O. Okagbare, S. Ova, L. Nkonyu, WCS Nigeria unpublished data 2017'}, // resynced January 2022\n\n  // BNS Prices 2017\n     // { id: 'aqwNyk7ikXxU9x4u77YfnS', tag: 'bns_price', name: 'Prices Crossriver 2017 ', owner: 'wcs_crossriver', instance: 'I. Imong, J. Ntui, O. Okagbare, S. Ova, L. Nkonyu, WCS Nigeria unpublished data 2017'}, // resynced January 2022\n     // { id: 'apMTFWRd9fQWHvpJHLfvk6', tag: 'bns_price', name: 'BNS Prix Lac Télé 2017', owner: 'wcs_lactele' , instance: 'G. Bondeko, N. Loundou, R. Mouanda, R. Mossaba, M. Boboto, D. Detoeuf, WCS Congo unpublished data 2017' }, // resynced January 2022\n     // { id: 'aTkDkjcfNN7vQJdZeJHkJq', tag: 'bns_price', name: 'Price Makira 2017', owner: 'wcs_mamabaie', instance: 'M. Ravelona, WCS Madagascar unpublished data 2017' }, // resynced January 2022\n     // { id: 'a6BjZ8ncLtTtfBSGZ9PqoJ', tag: 'bns_price', name: 'BNS Prix Ituri 2017', owner: 'wcs_ituri', instance: 'M. Enduyi, A. Tsongo, J. Maneno, O. Angauko, A. Ohole, WCS RDC unpublished data 2017'}, // resynced January 2022\n\n // NRGT 2017\n     // { id: 'apnzrb2RuoKu8Uxy2svwF6', tag: 'nrgt_historical', name: 'NRGT Crossriver 2017', owner: 'wcs_crossriver', instance:'I. Imong, J. Ntui, O. Okagbare, S. Ova, L. Nkonyu, WCS Nigeria unpublished data 2017' }, // resynced Oct 2022\n     // { id: 'aeWW3VLbdMDgUHHdoRCUH9', tag: 'nrgt_historical', name: 'NRGT Ituri 2017', owner: 'wcs_ituri', instance:'B. Ntumba, A. Ngomba, A. Walanga, I. Liengola, WCS RDC unpublished data 2017' }, // resynced January 2022\n     //  { id: 'aU6gbhMjfHyGekAma8wHhG', tag: 'nrgt_historical', name: 'NRGT Lac Télé 2017', owner: 'wcs_lactele', instance:'G. Bondeko, N. Loundou, R. Mouanda, R. Mossaba, M. Boboto, D. Detoeuf, WCS Congo unpublished data 2017' }, // resynced January 2022\n     // { id: 'asRbCJuyX3KJMFkB2p9Hh7', tag: 'nrgt_historical', name: 'NRGT Makira 2017', owner: 'wcs_mamabaie', instance:'N. Dokolahy, M. Ravelona, D. Detoeuf, WCS Madagascar unpublished data 2017' }, // resynced January 2022\n\n    ].map(survey => ({\n      formId: survey.id,\n      tag: survey.tag,\n      name: survey.name,\n      owner: survey.owner,\n      instance: survey.instance,\n      url: `https://kf.kobotoolbox.org/api/v2/assets/${survey.id}/data/?format=json`,\n      //* REPLACE L157 w/ the below URL to sync only 1 submision for each form; see \"limit=1\" *//\n      //url: `https://kf.kobotoolbox.org/api/v2/assets/${survey.id}/data/?format=json&limit=5`,\n    })),\n  };\n  console.log(`Fetching data for ${state.data.surveys.length} surveys.`);\n  return state;\n});\n\neach(dataPath('surveys[*]'), state => {\n  const { url, tag, formId, name, instance, owner } = state.data;\n  return get(url, {}, state => {\n    state.data.submissions = state.data.results.map((submission, i) => {\n      return {\n        i,\n        // Here we append the tags defined above to the Kobo form submission data\n        form: tag,\n        formName: name,\n        formOwner: owner,\n        instance: instance,\n        body: submission,\n      };\n    });\n    const count = state.data.submissions.length;\n    console.log(`Fetched ${count} submissions from ${formId} (${tag || ''}).`);\n    //Once we fetch the data, we want to post each individual Kobo survey\n    //back to the OpenFn inbox to run through the jobs =========================\n    return each(dataPath('submissions[*]'), state => {\n      console.log(`Posting ${state.data.i + 1} of ${count}...`);\n      return post(\"https://app.openfn.org/i/b3f86593-f37e-4139-80b8-852b9d3c49f4\", { body: state => state.data })(state);\n    })(state);\n    // =========================================================================\n  })(state);\n});\n\nalterState(state => {\n  console.log(`Finished at: ${new Date().toISOString()}`);\n  return {\n    data: {\n      message: \"No cursor required. Job fetches all submission for given forms.\"\n    },\n    references: []\n  };\n});\n",
          "adaptor": "@openfn/language-http@3.1.11",
          "project_credential_id": "50000511-d991-4efd-b41e-030dc4d9373a"
        }
      },
      "edges": {
        "cron->BNS-3-Get-all-Kobo-forms-on-demand": {
          "enabled": true,
          "id": "ccbb1f4d-3db9-4971-8ce8-62113192ffdc",
          "target_job_id": "1413d493-03a1-498a-88c9-662adf2a7e94",
          "source_trigger_id": "b4e57060-a0db-4c90-8519-1e7e36c576fc",
          "condition_type": "always"
        }
      }
    },
    "z[Archive]-Workflow-asana-test": {
      "id": "ceda6f64-bdbc-4a42-a7c8-408675b317f0",
      "name": "z[Archive] Workflow asana test",
      "inserted_at": "2025-03-18T09:51:46.174806Z",
      "lock_version": 6,
      "triggers": {
        "cron": {
          "enabled": false,
          "id": "1dc5ed35-2237-4575-b7d3-bd495323e8aa",
          "type": "cron",
          "cron_expression": "0 2 * * *"
        }
      },
      "jobs": {
        "asana-test": {
          "id": "45fbeae9-a894-40ad-bd43-fe2c8a933d2d",
          "name": "asana test",
          "body": "getTasks(\"11989019982662\",\n {\n   opt_fields: \"name,notes,assignee\"\n })\n",
          "adaptor": "@openfn/language-asana@latest",
          "project_credential_id": null
        }
      },
      "edges": {
        "cron->asana-test": {
          "enabled": true,
          "id": "998223a3-5750-410a-8e4c-bdc73b742014",
          "target_job_id": "45fbeae9-a894-40ad-bd43-fe2c8a933d2d",
          "source_trigger_id": "1dc5ed35-2237-4575-b7d3-bd495323e8aa",
          "condition_type": "always"
        }
      }
    },
    "A1-Generate-Jobs-DB-Tables-and-Dictionary-AUTO": {
      "id": "130c93c1-371a-4883-bc7e-073da26dc263",
      "name": "A1 Generate Jobs DB Tables and Dictionary AUTO",
      "inserted_at": "2025-03-18T09:51:59.813095Z",
      "lock_version": 6,
      "triggers": {
        "cron": {
          "enabled": false,
          "id": "6b373324-0767-4bc2-a668-1d4e26bd6e9c",
          "type": "cron",
          "cron_expression": "0 */3 * * *"
        }
      },
      "jobs": {
        "A1-Generate-Jobs-DB-Tables-and-Dictionary-AUTO": {
          "id": "f5836ca3-5263-4137-93e6-1b0eb51cb5e8",
          "name": "A1 Generate Jobs DB Tables and Dictionary AUTO",
          "body": "get('https://kf.kobotoolbox.org/api/v2/assets/?format=json', {}, state => {\n  console.log(`Previous cursor: ${state.lastEnd}`);\n  // Set a manual cursor if you'd like to only fetch form after a certain date\n  const manualCursor = '2019-05-25T14:32:43.325+01:00';\n\n  // ===========================================================================\n  // == FOR ADMINS: Update the below `manualFormList` to designate which Kobo forms to sync ==//\n\n  const manualFormList = [\n    //==================== Forms must be shared with the account openfn_kobo====================//\n    //=== WCS Camera trap metadata =====\n    // {\n    //     uid: 'axDXRTMWEkhrQDYQ9K3YdT', // Form name: 1. Project and cameras\n    //     p1: 'WCSPROGRAMS',\n    //     p2: 'CameraKobo',\n    //     tableId: 'Project' // Result is Run 062f3e43-46fe-7332-99e3-07cce87ddbdf\n    // },\n    {\n        uid: 'axfD6ntJyhfD2mxAGuVRSE', // Form name: 2. Deployments\n        p1: 'WCSPROGRAMS',\n        p2: 'CameraKobo',\n        tableId: 'Deployment' // Result is Run 062f3e47-ed7f-7fc5-b367-4c0f9b530053\n    },\n    // {\n    //     uid: 'a4yYjawjdbpHcckBx8m8AP', // Form name: 3. Retrieval\n    //     p1: 'WCSPROGRAMS',\n    //     p2: 'CameraKobo',\n    //     tableId: 'Retrieval' // Result is Run 062f3e43-10bc-7697-9417-11c931b14c8f\n    // },\n    // {\n    //     uid: 'a9F5e7wMMopSm85Abw3LTN', // Form name: 4. Images\n    //     p1: 'WCSPROGRAMS',\n    //     p2: 'CameraKobo',\n    //     tableId: 'Image'\n    // },\n    //=== WCS Socio Economic Database =====\n    // {\n    //     uid: 'aukhdejQU76K33caCkF4rP',\n    //     p1: 'WCSPROGRAMS',\n    //     p2: 'SocioEco',\n    //     tableId: 'SocioEcoSurvey'\n    // },\n    //==== SharksRays ===============//\n    // {\n    //   uid: 'aaknL3DQQgkgZ8iay89X5P',\n    //   p1: 'WCSPROGRAMS',\n    //   p2: '',\n    //   tableId: 'SharksRays',\n    // },\n    // {\n    //   uid: 'aStMvYShWXZsKYa7AyN6sr',\n    //   p1: 'WCSPROGRAMS',\n    //   p2: '',\n    //   tableId: 'SharksRays',\n    // },\n    // {\n    //   uid: 'aQeXAtEkgg8PGwxDiCUnPW',\n    //   p1: 'WCSPROGRAMS',\n    //   p2: '',\n    //   tableId: 'SharksRays',\n    // },\n    //=== Trillion Trees forms =====\n    // {\n    //   uid: 'aHPGTtrrLB4k3xDA9UZipu',\n    //   p1: 'WCSPROGRAMS',\n    //   p2: '',\n    //   tableId: 'Site',\n    // },\n    // {\n    //   uid: 'a8ffyF7HgbFUEnYBppEL79',\n    //   p1: 'WCSPROGRAMS',\n    //   p2: '',\n    //   tableId: 'Land',\n    // },\n    //=================================\n    // {\n    //   uid: 'avLpvrukkvuFzCHacjHdRs',\n    //   p1: 'WCS',\n    //   p2: 'Vegetation',\n    //   tableId: 'VegetationClassficationAndTreeMeasurementForm'},\n\n    //{ uid: 'apZrpKcK78xzrPcAfRrfac', p1: 'OpenFn', p2: 'Sharks', tableId: 'SharkRaysMay4Test'},\n    //{ uid: 'azg4rJb2Kk8DT2upSPyYjB', p1: 'WCS', p2: 'Livestock', tableId: 'LivestockProduction'},\n    //{ uid: 'aDgPJqN4SAYohZ4ZueEeYU', p1: 'WCS', p2: 'Arcadia', tableId: 'ArcadiaDataCollection'},\n    //{ uid: 'a7Dx4vpFcj7ziwaKE4682U', p1: 'WCS', p2: 'Vegetation', tableId: 'VegetationClassficationAndTreeMeasurementForm'},\n    //{ uid: 'apZrpKcK78xzrPcAfRrfac', p1: 'WCS', p2: 'SR', tableId: 'SharkAndRaysTraining'}\n  ];\n\n  state.data.forms = state.data.results\n    // Filter the response from Kobo to show only those forms we want to update.\n    .filter(form => manualFormList.map(x => x.uid).includes(form.uid))\n    .filter(form => {\n      // Note: If a form in manualFormList was not present in the list during\n      // the last run of the job (formsWatched), then we always trigger an\n      // update for that form.\n      if (!state.formsWatched) {\n        return true;\n      }\n      if (!state.formsWatched.find(f => f.uid === form.uid)) {\n        console.log(`New form ${form.uid} (${form.name}) added to watch list.`);\n        return true;\n      }\n      // Note: If a form is not NEW to the watch list, then we only trigger an\n      // update if it has been modified more recently than the greatest\n      // last-modified date across all forms from our last run.\n      return form.date_modified > (state.lastEnd || manualCursor);\n    })\n    // Map those forms so that we can post each to the inbox later.\n    .map(form => {\n      const url = form.url.split('?').join('?');\n      const manualSpec = manualFormList.find(f => f.uid === form.uid);\n      return {\n        formId: form.uid,\n        tag: manualSpec.surveyTable || form.name,\n        //tag: form.name,\n        url,\n        prefix1: manualSpec.p1,\n        prefix2: manualSpec.p2 || '',\n        tableId: manualSpec.tableId,\n        lastModified: form.date_modified,\n      };\n    });\n\n  // Set lastEnd to the greatest date_modified value for all forms we care about.\n  const lastEnd = state.data.results\n    .filter(item => item.date_modified)\n    .map(s => s.date_modified)\n    .sort((a, b) => new Date(b.date) - new Date(a.date))[0];\n\n  console.log(\n    'Detected changes for:',\n    JSON.stringify(\n      state.data.forms.map(f => f.url),\n      null,\n      2\n    )\n  );\n\n  return { ...state, lastEnd, formsWatched: manualFormList };\n});\n\neach(dataPath('forms[*]'), state => {\n  const form = state.data;\n  return post(\n    state.configuration.openfnInboxUrl,\n    { body: { ...form, formUpdate: true } },\n    state => {\n      console.log('Sent ', form.tag, ' for handling:');\n      console.log(form);\n      return state;\n    }\n  )(state);\n});\n\n// Clear everything from state but the required cursors.\nalterState(state => ({\n  lastEnd: state.lastEnd,\n  formsWatched: state.formsWatched,\n}));\n",
          "adaptor": "@openfn/language-http@v4.0.0",
          "project_credential_id": null
        }
      },
      "edges": {
        "cron->A1-Generate-Jobs-DB-Tables-and-Dictionary-AUTO": {
          "enabled": true,
          "id": "2e483885-f409-4328-8a61-e1d7fb41a0b0",
          "target_job_id": "f5836ca3-5263-4137-93e6-1b0eb51cb5e8",
          "source_trigger_id": "6b373324-0767-4bc2-a668-1d4e26bd6e9c",
          "condition_type": "always"
        }
      }
    },
    "A2-Process-Forms-AUTO": {
      "id": "32090694-7fd3-4131-b68c-f2372fa9623b",
      "name": "A2 Process Forms AUTO",
      "inserted_at": "2025-03-18T09:52:34.551761Z",
      "lock_version": 6,
      "triggers": {
        "webhook": {
          "enabled": false,
          "id": "ec90e89e-9fd3-4d26-ab9f-df0dc01a0629",
          "type": "webhook"
        }
      },
      "jobs": {
        "A2-Process-Forms-AUTO": {
          "id": "ea64cfd3-401d-4c36-a708-a4aa89ea4f05",
          "name": "A2 Process Forms AUTO",
          "body": "get(`${state.data.url}`, {}, state => {\n  state.formDefinition = state.data; // keeping form definition for data dictionary\n  const tablesToBeCreated = [];\n  const { survey, choices } = state.data.content;\n  if (survey.length === 0) {\n    console.log(\n      'No survey available or defined to analyze. Please check the Kobo form deployment status'\n    );\n    return state;\n  }\n  // PREFIX HANDLER\n  const prefix1 = state.references[0].prefix1 || 'WCS';\n  const prefix2 = state.references[0].prefix2 || '';\n  const tableId = state.references[0].tableId;\n  const uuidColumnName = 'generated_uuid';\n  const prefixes = [prefix1, prefix2].join('_');\n  // END OF PREFIX HANDLER\n\n  const multiSelectIds = [];\n\n  const mapType = {\n    calculate: 'varchar(100)',\n    date: 'date',\n    decimal: 'float4',\n    end: 'date',\n    integer: 'int4',\n    select_one: 'select_one',\n    start: 'date',\n    text: 'text',\n    today: 'date',\n    jsonb: 'jsonb',\n    select_multiple: 'select_multiple',\n    geopoint: 'text',\n  };\n\n  const discards = [\n    'begin_group',\n    'begin_repeat',\n    'end_group',\n    'end_repeat',\n    'note',\n  ];\n\n  // Camelize columns and table name\n  function toCamelCase(str) {\n    if (!str) return '';\n    let underscores = [];\n    let i = 0;\n    while (str[i] === '_') {\n      underscores.push(str[i]);\n      i++;\n    }\n    let words = str.match(/[0-9a-zA-Z\\u00C0-\\u00FF]+/gi);\n    if (!words) return '';\n    words = words\n      .map(word => {\n        return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();\n      })\n      .join('');\n    return `${underscores.join('')}${words}${underscores.join('')}`;\n  }\n\n  function questionsToColumns(questions) {\n    var form = questions.filter(elt => !discards.includes(elt.type));\n\n    form.forEach(obj => (obj.type = mapType[obj.type] || 'text'));\n\n    form.forEach(obj => {\n      // List of reserved keys in postgresql and their transformations\n      if (obj.name === 'group') {\n        obj.name = 'kobogroup';\n      }\n      if (obj.name == 'end') {\n        obj.name = 'form_date__end';\n      }\n      if (obj.name == 'column') {\n        obj.name = 'column_name';\n      }\n      if (obj.name == 'date') {\n        obj.name = 'date_value';\n      }\n      if (obj.type === 'select_one') {\n        obj.type = 'int4';\n        obj.select_one = true;\n        delete obj.default;\n      }\n    });\n\n    form.forEach(q => {\n      if (q.name === 'gps') {\n        form.push({ name: 'latitude', type: 'float4' });\n        form.push({ name: 'longitude', type: 'float4' });\n      }\n    });\n\n    form = form.map(x => {\n      let name = toCamelCase(x.name) || toCamelCase(x.$autoname);\n      name = x.select_one\n        ? `${prefixes}${toCamelCase(x.select_from_list_name)}ID_${name}`\n        : name;\n      return {\n        ...x,\n        name: `${name.split(/-/).join('_')}`,\n        findValue: x.select_one || x.type === 'select_multiple' || false,\n        required: x.required,\n      };\n    });\n\n    const parentColumn =\n      // questions[0].path.length > 1\n      questions[0].depth > 1\n        ? `${questions[0].path.slice(-2, -1)[0]}_uuid`\n        : `${tableId}_uuid`;\n\n    if (questions[0].depth > 0)\n      form.push({ name: toCamelCase(parentColumn), type: 'text' });\n\n    form.push(\n      { name: 'AnswerId', type: 'text' },\n      { name: toCamelCase(uuidColumnName), type: 'varchar(100)', unique: true }\n    );\n\n    return form;\n  }\n\n  function standardColumns(tableName) {\n    // prettier-ignore\n    return [\n      // { name: `${prefix1}${tableName}ID`, type: 'int4', required: true, identity: true },\n      // { name: `${prefix1}${tableName}Name`, type: 'varchar(255)', required: false },\n      // { name: `${prefix1}${tableName}ExtCode`, type: 'varchar(50)', required: true, default: '' },\n      { name: `${prefixes}${tableName}Code`, type: 'varchar(255)', required: false },\n      { name: `${prefixes}${tableName}Description`, type: 'varchar(255)', required: false },\n      { name: `${prefixes}OrganizationID_Owner`, type: 'int4', required: true, default: 1 },\n      { name: `${prefixes}SecuritySettingID_Row`, type: 'int4', required: true, default: 1 },\n      { name: 'Archive', type: 'BIT', required: true, default: '0' },\n      { name: 'IsPublic', type: 'BIT', required: true, default: '0' },\n      { name: 'CRDate', type: 'timestamp', required: true, default: 'NOW()' },\n      { name: 'LMDate', type: 'timestamp', required: true, default: 'NOW()' },\n      { name: 'UserID_CR', type: 'int4', required: true, default: -1 },\n      { name: 'UserID_LM', type: 'int4', required: true, default: -1 },\n      { name: 'CRIPAddress', type: 'varchar(32)', required: true, default: '' },\n      { name: 'LMIPAddress', type: 'varchar(32)', required: true, default: '' },\n    ];\n  }\n\n  function customColumns(tableName) {\n    // prettier-ignore\n    return [\n      { name: `${prefixes}${tableName}ID`, type: 'int4', required: true, identity: true },\n      { name: `${prefixes}${tableName}Name`, type: 'varchar(255)', required: false },\n      { name: `${prefixes}${tableName}ExtCode`, type: 'varchar(50)', required: true, default: '' },\n    ];\n  }\n\n  function processPath(question, i, arr) {\n    let path = [];\n    if (i === 0) {\n      path = [];\n    } else {\n      let parent = arr.find(question => question.name === arr[i - 1].path[0]);\n      if (parent && parent.type === 'begin_group') {\n        path = [[arr[i - 1].path, question.name].join('/')];\n      } else {\n        path = i === 0 ? [] : [...arr[i - 1].path, question.name];\n      }\n    }\n    return path;\n  }\n\n  function buildLookupTableColumns(prefixes, q, i, arr) {\n    const path = processPath(q, i, arr);\n    return [\n      {\n        name: `${prefixes}${toCamelCase(q.select_from_list_name)}ID`,\n        type: 'int4',\n        identity: true,\n        required: q.required,\n        depth: path.length,\n        select_multiple: q.type === 'select_multiple' ? true : false,\n        path,\n        rule: 'DO_NOT_MAP',\n        parentColumn: q.name,\n      },\n      {\n        name: `${prefixes}${toCamelCase(q.select_from_list_name)}Name`,\n        type: 'varchar(100)',\n        required: q.required,\n        depth: path.length,\n        select_multiple: q.type === 'select_multiple' ? true : false,\n        path,\n        parentColumn: q.name,\n      },\n      {\n        name: `${prefixes}${toCamelCase(q.select_from_list_name)}ExtCode`,\n        type: 'varchar(100)',\n        required: q.required,\n        unique: true,\n        depth: q.type === 'select_multiple' ? 3 : 0,\n        select_multiple: q.type === 'select_multiple' ? true : false,\n        path: i === 0 ? [] : [...arr[i - 1].path, q.name],\n        parentColumn: q.name,\n      },\n    ];\n  }\n\n  // prettier-ignore\n  function addLookupTable(tables, lookupTableName, prefixes, q, i, formName, arr) {\n    tables.push({\n      name: lookupTableName,\n      columns: buildLookupTableColumns(prefixes, q, i, arr),\n      defaultColumns: standardColumns(toCamelCase(q.select_from_list_name)),\n      formName,\n      depth: q.type === 'select_multiple' ? 1 : q.depth,\n      lookupTable: q.type === 'select_multiple' ? true : undefined,\n      select_from_list_name: toCamelCase(q.select_from_list_name),\n      ReferenceUuid: `${prefixes}${toCamelCase(q.select_from_list_name)}ExtCode`,\n    });\n    tablesToBeCreated.push(lookupTableName)\n  }\n\n  function buildForeignTables(questions) {\n    const foreignTables = [];\n    questions.forEach(q => {\n      if (q.select_one) {\n        foreignTables.push({\n          table: `${prefixes}${toCamelCase(q.select_from_list_name)}`,\n          id: `${prefixes}${toCamelCase(q.select_from_list_name)}ID`,\n          reference: `${prefixes}${toCamelCase(\n            q.select_from_list_name\n          )}ID_${toCamelCase(q.name)}`,\n        });\n      }\n    });\n    return foreignTables;\n  }\n\n  function buildTablesFromSelect(questions, formName, tables) {\n    questions.forEach((q, i, arr) => {\n      if (q.type === 'select_multiple') {\n        multiSelectIds.push(q.name);\n        const getType = name => survey.find(s => s.name === name).type; // return the type of a question\n\n        let suffix = q.path.slice(-1)[0];\n        if (suffix && getType(suffix) === 'begin_group') suffix = undefined;\n\n        const lookupTableName = `${prefixes}${toCamelCase(\n          q.select_from_list_name\n        )}`;\n\n        const junctionTableName = `${prefixes}${toCamelCase(\n          suffix || tableId\n        )}${toCamelCase(q.select_from_list_name)}`;\n\n        // prettier-ignore\n        const parentTableName = `${prefixes}${tableId}${toCamelCase(suffix)}`;\n        // prettier-ignore\n        const parentTableReferenceColumn = `${prefixes}${toCamelCase(suffix || tableId)}ID`;\n\n        if (!tables.find(t => t.name === junctionTableName)) {\n          // console.log('junctiontable', junctionTableName);\n          const path = processPath(q, i, arr);\n          tables.push({\n            name: junctionTableName,\n            dependencies: 3,\n            columns: [\n              {\n                name: `${prefixes}${toCamelCase(q.select_from_list_name)}ID`,\n                type: 'select_multiple',\n                required: q.required,\n                referent: lookupTableName,\n                refersToLookup: true,\n                depth: path.length,\n                path,\n              },\n              {\n                name: parentTableReferenceColumn,\n                type: 'select_multiple',\n                required: q.required,\n                referent: parentTableName,\n                refersToLookup: false,\n                depth: path.length,\n                path,\n              },\n            ],\n            defaultColumns: [\n              // prettier-ignore\n              ...[\n                { name: `${prefixes}${toCamelCase(q.select_from_list_name)}Name`, type: 'varchar(255)', required: false },\n                { name: `${prefixes}${toCamelCase(q.select_from_list_name)}ExtCode`, type: 'varchar(50)', required: true, default: '' },\n              ],\n              ...standardColumns(toCamelCase(q.select_from_list_name)),\n            ],\n            foreignTables: [\n              {\n                table: lookupTableName,\n                id: `${lookupTableName}ID`,\n              },\n              {\n                table: parentTableName,\n                id: `${prefixes}${toCamelCase(suffix || tableId)}ID`,\n              },\n            ],\n            formName,\n            depth: 1,\n            select_multiple: true,\n            select_from_list_name: toCamelCase(q.select_from_list_name),\n          });\n          tablesToBeCreated.push(junctionTableName);\n        }\n      }\n\n      if (['select_one', 'select_multiple'].includes(q.type)) {\n        // Use list_name to name select_table\n        const lookupTableName = `${prefixes}${toCamelCase(\n          q.select_from_list_name\n        )}`;\n        if (!tablesToBeCreated.includes(lookupTableName)) {\n          // console.log('lookup', lookupTableName);\n          //prettier-ignore\n          addLookupTable(tables, lookupTableName, prefixes, q, i, formName, arr);\n        }\n      }\n    });\n    return tables;\n  }\n\n  function tablesFromQuestions(questions, formName, tables) {\n    const backwardsFirstBegin = questions\n      .reverse()\n      .findIndex(item => item.type === 'begin_repeat');\n\n    const lastBegin =\n      backwardsFirstBegin !== -1\n        ? questions.length - backwardsFirstBegin - 1\n        : false;\n\n    const tName = `${prefixes}${tableId}`;\n\n    if (lastBegin) {\n      const firstEndAfterLastBegin =\n        questions\n          .reverse()\n          .slice(lastBegin)\n          .findIndex(item => item.type === 'end_repeat') + lastBegin;\n\n      // Remove the deepest repeat group from the 'questions' array, parse it\n      // and push it to the 'tables' array, and call tablesFromQuestions with\n      // the remaining questions.\n      const group = questions.splice(\n        lastBegin,\n        firstEndAfterLastBegin - lastBegin + 1\n      );\n\n      const tableName = toCamelCase(\n        group[0].path\n          .slice(-1)\n          .pop()\n          .split(/\\s|-|'/)\n          .join('_')\n          .replace('.', '')\n      );\n      const name = `${prefixes}${tableId}${tableName}`;\n\n      tables.push({\n        name,\n        dependencies: 2,\n        columns: questionsToColumns(\n          group.filter(q => q.type !== 'select_multiple')\n        ),\n        defaultColumns: [\n          // prettier-ignore\n          ...[ { name: `${tName}ID`, type: 'int4', required: false } ],\n          ...customColumns(tableName),\n          ...standardColumns(tableName),\n        ],\n        foreignTables: [\n          ...[\n            {\n              table: tName,\n              id: `${tName}ID`,\n            },\n          ],\n          ...buildForeignTables(group),\n        ],\n        formName,\n        depth: group[0].depth,\n      });\n      tablesToBeCreated.push(name);\n\n      return tablesFromQuestions(questions, formName, tables);\n    }\n\n    tables.push(\n      {\n        // This is the main table to hold submissions for this Kobo form.\n        name: tName,\n        dependencies: 1,\n        columns: [\n          // Note that we do not create columns for select multiple Qs. Answers\n          // to select multiple Qs will appear as records in a junction table.\n          ...questionsToColumns(\n            questions.filter(q => q.type !== 'select_multiple')\n          ),\n          ...[\n            {\n              name: 'Payload',\n              type: 'jsonb',\n              depth: 0,\n              path: [],\n            },\n          ],\n        ],\n        defaultColumns: [\n          ...customColumns(tableId),\n          ...standardColumns(tableId),\n        ],\n        foreignTables: buildForeignTables(questions),\n        formName,\n        depth: 0,\n      },\n      {\n        name: `${prefix1}_KoboDataset`,\n        // This is a table that must exist in all DBs that will hold submission data from any form.\n        columns: [\n          {\n            name: 'FormName',\n            type: 'text',\n            depth: 0,\n            path: [],\n          },\n          {\n            name: 'DatasetId',\n            type: 'varchar(100)',\n            depth: 0,\n            path: [],\n            unique: true,\n          },\n          {\n            name: 'LastUpdated',\n            type: 'timestamp',\n            depth: 0,\n            path: [],\n          },\n        ],\n        defaultColumns: [\n          {\n            name: `${prefix1}ID`,\n            type: 'int4',\n            required: true,\n            identity: true,\n          },\n          {\n            name: `${prefix1}Name`,\n            type: 'varchar(255)',\n            required: false,\n          },\n          {\n            name: `${prefix1}ExtCode`,\n            type: 'varchar(50)',\n            required: true,\n            default: '',\n          },\n          {\n            name: `${prefix1}Code`,\n            type: 'varchar(255)',\n            required: false,\n          },\n          {\n            name: `${prefix1}Description`,\n            type: 'varchar(255)',\n            required: false,\n          },\n          {\n            name: `${prefix1}OrganizationID_Owner`,\n            type: 'int4',\n            required: true,\n            default: 1,\n          },\n          {\n            name: `${prefix1}SecuritySettingID_Row`,\n            type: 'int4',\n            required: true,\n            default: 1,\n          },\n          { name: 'Archive', type: 'BIT', required: true, default: '0' },\n          { name: 'IsPublic', type: 'BIT', required: true, default: '0' },\n          {\n            name: 'CRDate',\n            type: 'timestamp',\n            required: true,\n            default: 'NOW()',\n          },\n          {\n            name: 'LMDate',\n            type: 'timestamp',\n            required: true,\n            default: 'NOW()',\n          },\n          { name: 'UserID_CR', type: 'int4', required: true, default: -1 },\n          { name: 'UserID_LM', type: 'int4', required: true, default: -1 },\n          {\n            name: 'CRIPAddress',\n            type: 'varchar(32)',\n            required: true,\n            default: '',\n          },\n          {\n            name: 'LMIPAddress',\n            type: 'varchar(32)',\n            required: true,\n            default: '',\n          },\n        ],\n        formName,\n        depth: 0,\n      }\n    );\n    tablesToBeCreated.push(tName);\n\n    return tables;\n  }\n\n  // We build a dictionary of different select_one/select_multiple questions\n  // and the different values they hold ===================================\n  function createSeeds(choicesArr) {\n    const obj = {};\n\n    choicesArr.forEach(c => {\n      const table = `${prefixes}${toCamelCase(c.list_name)}`;\n      if (!obj[table]) obj[table] = [];\n      if (!obj[table].includes(c.name)) obj[table].push(c.name);\n    });\n\n    const arr = [];\n\n    Object.keys(obj).forEach(table => {\n      arr.push({\n        table: table,\n        externalId: `${table}ExtCode`,\n        records: [...obj[table]],\n      });\n    });\n\n    return arr;\n  }\n\n  let depth = 0;\n\n  survey.forEach((q, i, arr) => {\n    switch (q.type) {\n      case 'begin_group':\n        arr[i] = {\n          ...q,\n          depth,\n          path: i === 0 ? [] : [...arr[i - 1].path, q.name],\n        };\n        break;\n\n      case 'begin_repeat':\n        depth++;\n        arr[i] = {\n          ...q,\n          depth,\n          path: i === 0 ? [] : [...arr[i - 1].path, q.name],\n        };\n        break;\n\n      case 'end_repeat':\n        arr[i] = {\n          ...q,\n          depth,\n          path: i === 0 ? [] : [...arr[i - 1].path.slice(0, -1)],\n        };\n        depth--;\n        break;\n\n      case 'end_group':\n        arr[i] = {\n          ...q,\n          depth,\n          path: i === 0 ? [] : [...arr[i - 1].path.slice(0, -1)],\n        };\n        break;\n\n      default:\n        arr[i] = {\n          ...q,\n          depth,\n          path: i === 0 ? [] : [...arr[i - 1].path],\n        };\n        break;\n    }\n  });\n\n  const seeds = createSeeds(choices);\n  const lookupTables = buildTablesFromSelect(survey, state.data.name, []);\n  let tables = tablesFromQuestions(survey, state.data.name, []).reverse();\n  tables = lookupTables.concat(tables);\n\n  // Given the initial input of a \"Kobo form definition\", we return...\n  return {\n    ...state,\n    tableId, // this is unique per form and used to identify the main \"submissions table\" for the form\n    tables, // this is a list of tables (main table, lookup tables, junction tables, etc.) to create in the db\n    seeds, // this is a list of records (grouped by table) to insert at build time, not form submission time (runtime)\n    prefix1, // this is a constant used in various places\n    prefix2, // this is a constant used in various places\n    prefixes, // this is `{prefix1}_{prefix2}`\n    uuidColumnName, // this is a constant used identify unique ID columns in the db\n    multiSelectIds, // this is an array of the 'list_name' of every select_multiple question\n    data: {}, // we clear data\n    response: {}, // we clear response\n  };\n});\n\n// Sort the tables by dependencies so that we can create them in the correct order\nfn(state => ({\n  ...state,\n  tables: state.tables.sort((a, b) =>\n    !b.hasOwnProperty('dependencies')\n      ? 1\n      : a.dependencies > b.dependencies\n      ? 1\n      : -1\n  ),\n}));\n\n// Print out a \"DROP STATEMENT\" for each table in the list of tables.\nfn(state => {\n  console.log('====================DROP STATEMENT====================');\n  console.log('Use this to clean database from created tables...');\n\n  const { tables } = state;\n\n  const query = `DROP TABLE ${tables.map(t => t.name).reverse()};`;\n\n  console.log(`query: ${query}`);\n  console.log('====================END DROP STATEMENT====================');\n\n  return state;\n});\n",
          "adaptor": "@openfn/language-http@v4.0.0",
          "project_credential_id": null
        },
        "A4-Generate-OpenFn-Job-script-AUTO---OPENFN-JOB": {
          "id": "ddcb3bd8-a268-4f74-bae5-8b1c203244cb",
          "name": "A4 Generate OpenFn Job script AUTO - OPENFN JOB",
          "body": "// {\n//   ...state,\n//   tableId, // this is unique per form and used to identify the main \"submissions table\" for the form\n//   tables, // this is a list of tables (main table, lookup tables, junction tables, etc.) to create in the db\n//   seeds, // this is a list of records (grouped by table) to insert at build time, not form submission time (runtime)\n//   prefix1, // this is a constant used in various places\n//   prefix2, // this is a constant used in various places\n//   prefixes, // this is `{prefix1}_{prefix2}`\n//   uuidColumnName, // this is a constant used identify unique ID columns in the db\n//   multiSelectIds, // this is an array of the 'list_name' of every select_multiple question\n//   data: {}, // we clear data\n//   response: {}, // we clear response\n// };\n\n// Pluck projectId out of state for convenience, filter out tables that were populated at build time.\nfn(state => {\n  const { projectId } = state.configuration;\n\n  return {\n    ...state,\n    projectId,\n    tables: state.tables\n      .filter(t => !t.ReferenceUuid) // filter out tables that were seeded\n      .filter(t => t.columns.length > 0) // filter out tables with no columns\n      .filter(t => t.name !== `${state.prefixes}_Untitled`), // filter out bad test data\n  };\n});\n\nfn(state => {\n  // Create the first operation in our expression.\n  var expression = `fn(state => {\n  const multiSelectIds = [\"${state.multiSelectIds.join('\", \"')}\"];\n\n  function generateUuid(body, uuid) {\n    for (const property in body) {\n      if (Array.isArray(body[property]) && body !== null) {\n        body['__generatedUuid'] = uuid;\n        body[property].forEach((thing, i, arr) => {\n          if (thing !== null) {\n            thing['__parentUuid'] = uuid;\n            let newUuid = uuid + '-' + (i + 1);\n            thing['__generatedUuid'] = newUuid;\n            for (const property in thing) {\n              if (Array.isArray(thing[property])) {\n                generateUuid(thing, newUuid);\n              }\n            }\n          }\n        });\n      }\n    }\n  }\n\n  generateUuid(\n    state.data.body,\n    state.data.body._id+'-'+state.data.body._xform_id_string\n  );\n\n  const { body } = state.data;\n  const { _id, _xform_id_string } = body;\n  state.data = { ...state.data, ...body };\n\n  return { ...state, _id, _xform_id_string };\n}); \\n`;\n\n  function toCamelCase(str) {\n    const words = str.split('_'); // we split using '_'. With regex we would use: \"match(/[a-z]+/gi)\"\n    if (!words) return '';\n    return words\n      .map(word => {\n        return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();\n      })\n      .join('');\n  }\n\n  // Iterate through every table and create an operation to upsert (or upsertMany) records for that table.\n  for (const table of state.tables) {\n    const { columns, name, depth, select_multiple, lookupTable } = table;\n    var paths = [];\n\n    for (const column of columns) {\n      // Handling master parent table\n      if (name === `${state.prefix1}_KoboDataset`) {\n        const values = {\n          FormName: \"dataValue('formName')\",\n          DatasetId: \"dataValue('_xform_id_string')\",\n          LastUpdated: 'new Date().toISOString()',\n        };\n        for (x in values) paths.push(values[x]);\n        break;\n      }\n      // end of master parent table\n\n      const currentPath = column.path;\n\n      paths.push(\n        (currentPath && currentPath.length > 0\n          ? currentPath.join('/') + '/'\n          : '') + column.$autoname\n      );\n    }\n\n    var mapKoboToPostgres = {}; // This is the jsonBody that should be given to our upsert\n\n    // We generate findValue function (fn) for those that needs it.\n    function generateFindValue(question, relation, searchAttr, searchVal) {\n      const inferredUUid =\n        // if not junction, but yes select_one or many...\n        !question.referent && question.findValue\n          ? toCamelCase(\n              question.select_from_list_name.replace(`${state.tableId}_`, '')\n            )\n          : question.name;\n\n      const suffixedUUid = !inferredUUid.endsWith('ID')\n        ? `${inferredUUid}ID`\n        : `${inferredUUid}`;\n\n      const finalUUid = !suffixedUUid.startsWith(state.prefixes)\n        ? `${state.prefixes}${suffixedUUid}`\n        : suffixedUUid;\n\n      searchAttr = searchAttr.replace('ID', '');\n\n      if (question.referent) {\n        // if it's in a junction\n        if (question.refersToLookup) {\n          // and it refers to lookup\n          searchAttr = `${question.referent}ExtCode`;\n          searchVal = `x`;\n        }\n        // if it doesn't we don't touch it!\n      } else {\n        searchAttr = !searchAttr.includes(state.prefixes)\n          ? `${state.prefixes}${searchAttr}ExtCode`\n          : `${searchAttr}ExtCode`;\n\n        searchVal =\n          question.depth > 0\n            ? `x['${searchVal}']`\n            : `dataValue('${searchVal}')`;\n      }\n\n      return `await findValue({uuid: '${finalUUid.toLowerCase()}', relation: '${relation.replace(\n        'ID',\n        ''\n      )}', where: { ${searchAttr}: ${searchVal} }})(state)`;\n    }\n\n    // FROM HERE WE ARE BUILDING MAPPINGS\n    columns.forEach((col, i) => {\n      if (col.rule !== 'DO_NOT_MAP') {\n        if (col.findValue) {\n          mapKoboToPostgres[col.name] = generateFindValue(\n            col,\n            `${state.prefixes}${toCamelCase(col.select_from_list_name)}`,\n            `${toCamelCase(col.select_from_list_name)}`,\n            paths[i]\n          );\n        } else if (col.name === 'Latitude') {\n          mapKoboToPostgres[col.name] = `state => state.data.gps.split(' ')[0]`;\n        } else if (col.name === 'Longitude') {\n          mapKoboToPostgres[col.name] = `state => state.data.gps.split(' ')[1]`;\n        } else if (col.name === 'Payload') {\n          // Here we use an expression, rather than a function, to take the ======\n          // original, unaltered body of the Kobo submission as JSON.\n          mapKoboToPostgres.Payload = `state.data.body`;\n        } else if (col.referent) {\n          // If we see a referent, this is a column in a junction table.\n          if (col.refersToLookup) {\n            // If refersToLookup is true, then this column refers to the lookup table\n            mapKoboToPostgres[col.name] = generateFindValue(\n              col,\n              col.referent,\n              `${col.select_from_list_name}`,\n              'x'\n            );\n            // if If refersToLookup is false, this column refers to the main submission table\n            // TODO: Mamadou, please confirm the line below. Should it change to \"findValue\"?\n          } else {\n            mapKoboToPostgres[col.name] = generateFindValue(\n              col,\n              col.referent,\n              'AnswerId',\n              'state._id'\n            );\n          }\n        } else if (col.depth > 0) {\n          mapKoboToPostgres[col.name] = `x['${paths[i]}']`;\n        } else {\n          mapKoboToPostgres[col.name] =\n            name !== `${state.prefix1}_KoboDataset`\n              ? col.parentColumn\n                ? `dataValue('${col.path.join('/')}')`\n                : `dataValue('${paths[i]}')`\n              : `${paths[i]}`;\n        }\n\n        if (col.name === 'AnswerId') {\n          mapKoboToPostgres[col.name] = `state._id`;\n        }\n        if (col.name === 'GeneratedUuid') {\n          if (depth > 0) mapKoboToPostgres[col.name] = `x['__generatedUuid']`;\n          else mapKoboToPostgres[col.name] = `dataValue('__generatedUuid')`;\n        }\n      }\n    });\n\n    // =====================================================================\n\n    // We generate a mapping variable that we are going=======\n    // to use inside our operation============================\n    const mapObject = `const mapping = ${JSON.stringify(\n      mapKoboToPostgres,\n      null,\n      2\n    ).replace(/\"/g, '')}`;\n    // =======================================================\n\n    // We build a set of statements for when depth > 0========\n    const path = columns[0].path.join('/');\n\n    let statements = null;\n    // console.log('select', select_multiple);\n    // console.log('name', depth);\n    // if table is a table referencing a select multiple table.\n    if (select_multiple || lookupTable) {\n      statements = `if (state.data['${path}']) { \\n\n                const array = state.data['${path}'].split(' '); \\n\n                const mapping = []; \\n \n                for ( let x of array ) { \\n\n                  mapping.push(${JSON.stringify(\n                    mapKoboToPostgres,\n                    null,\n                    2\n                  ).replace(/\"/g, '')}); \\n\n                } \\n\n            `;\n    } else {\n      //   statements = `if (state.data['${path}']) { \\n\n      //     const array = state.data['${path}'].split(' '); \\n\n      //     const mapping = []; \\n\n      //     for ( let x of array ) { \\n\n      //       mapping.push(${JSON.stringify(mapKoboToPostgres, null, 2).replace(\n      //         /\"/g,\n      //         ''\n      //       )}); \\n\n      //     } \\n\n      // }`;\n      statements = `const dataArray = state.data.body['${path}'] || [] \\n\n        const mapping = []; \\n\n        for (let x of dataArray) { \\n\n          mapping.push(${JSON.stringify(mapKoboToPostgres, null, 2).replace(\n            /\"/g,\n            ''\n          )}) \\n\n          }`;\n    }\n    // =======================================================\n\n    const opFirstLineNoDepth = `fn(async state => {\\n ${mapObject} \\n`;\n    const opFirstLineDepth = `fn(async state => {\\n ${statements} \\n`;\n    // const alterSOpeningSelect = `fn(async state => {\\n ${selectStatement} \\n`;\n    const opLastLine = `})`;\n\n    function wrapper(column, mapping) {\n      let prefix = '';\n      const depth = column.depth;\n      /*  if (select_multiple || lookupTable) {\n          prefix += mapping + `)(state); \\n${alterSClosing} \\n`;\n          return prefix;\n        } else */ if (depth > 1) {\n        // console.log('Im here');\n        let closingPar = 0; // hold how many brackets we need to close\n        for (var i = 0; i < depth - 1; i++) {\n          if (i === 0 && column.path[i]) {\n            // We generate \"body.something\" only for the first 'each'\n            prefix += `each('$.${column.path[i]}[*]', `;\n            closingPar++;\n          } else if (column.path[i]) {\n            prefix += `each(dataPath('${column.path[i]}[*]'), `;\n            closingPar++;\n          }\n        }\n        // prefix += mapping;\n        prefix +=\n          mapping +\n          (select_multiple || lookupTable\n            ? `)(state); } \\n return state; \\n${opLastLine} \\n`\n            : `)(state); \\n${opLastLine} \\n`);\n        for (var i = 0; i < closingPar; i++) {\n          prefix += ')';\n        }\n\n        return prefix;\n      }\n      return mapping;\n    }\n\n    const operation = `return ${depth > 0 ? 'upsertMany' : 'upsert'}`;\n\n    var uuid =\n      name === `${state.prefix1}_KoboDataset`\n        ? '\"DatasetId\"'\n        : table.select_multiple\n        ? `[\"${columns[0].name}\", \"${columns[1].name}\"]`\n        : `'${toCamelCase(state.uuidColumnName)}'`;\n\n    let mapping =\n      depth > 0 || select_multiple\n        ? `${opFirstLineDepth} ${operation}('${name}', ${uuid}, `\n        : `${opFirstLineNoDepth} ${operation}('${name}', ${uuid}, `;\n\n    if (columns[0].depth > 0 || select_multiple) {\n      mapping += `() => mapping, {setNull: [\"''\", \"'undefined'\"]}`;\n    } else {\n      mapping += `mapping, {setNull: [\"''\", \"'undefined'\"]}`;\n    }\n    // END OF BUILDING MAPPINGS (state)\n\n    expression +=\n      wrapper(columns[0], mapping) +\n      (columns[0].depth > 1\n        ? '\\n'\n        : select_multiple || lookupTable\n        ? `)(state); } \\n return state; \\n${opLastLine} \\n`\n        : `)(state); \\n${opLastLine} \\n`);\n  }\n\n  state.triggerCriteria = {\n    tableId: `${state.prefixes}${state.tableId}`,\n  };\n\n  return { ...state, expression };\n});\n\n// Get existing triggers for this project.\nfn(state => {\n  return request(\n    {\n      method: 'get',\n      path: 'triggers',\n      params: {\n        project_id: state.projectId,\n      },\n    },\n    next => ({ ...next, triggers: next.data })\n  )(state);\n});\n\n// Get existing jobs for this project.\nfn(state => {\n  return request(\n    {\n      method: 'get',\n      path: 'jobs',\n      params: {\n        project_id: state.projectId,\n      },\n    },\n    next => ({ ...next, jobs: next.data.filter(job => !job.archived) })\n  )(state);\n});\n\n// Create or update the trigger to detect submissions from this form.\nfn(state => {\n  const { triggers, prefixes, tableId, triggerCriteria, projectId } = state;\n  const triggerNames = triggers.map(t => t.name);\n\n  const name = `auto/${prefixes}${tableId}`;\n  const criteria = triggerCriteria;\n  const triggerIndex = triggerNames.indexOf(name);\n\n  const trigger = {\n    project_id: projectId,\n    name,\n    type: 'message',\n    criteria,\n  };\n\n  if (triggerIndex === -1) {\n    console.log('Inserting trigger.');\n    return request(\n      {\n        method: 'post',\n        path: 'triggers',\n        data: { trigger },\n      },\n      next => ({ ...next, triggers: [...next.triggers, next.data] })\n    )(state);\n  }\n\n  console.log('Trigger already existing.');\n  return state;\n});\n\n// Create or update the job for handling submissions from this form.\nfn(state => {\n  const { expression, prefixes, tableId, jobs, triggers, projectId } = state;\n\n  console.log('Inserting/updating job: ', `auto/${prefixes}${tableId}`);\n\n  const jobNames = jobs.map(j => j.name);\n  const triggersName = triggers.map(t => t.name);\n  const name = `auto/${prefixes}${tableId}`;\n  const jobIndex = jobNames.indexOf(name); // We check if there is a job with that name.\n  const triggerIndex = triggersName.indexOf(name);\n  const triggerId = triggers[triggerIndex].id;\n\n  const method = jobIndex !== -1 ? 'put' : 'post';\n  const path = method === 'put' ? `jobs/${jobs[jobIndex].id}` : 'jobs/';\n\n  const job = {\n    adaptor: 'mssql',\n    adaptor_version: 'v2.6.11',\n    expression,\n    name,\n    project_id: projectId,\n    trigger_id: triggerId, // we (1) create a trigger first; (2) get the id ; (3) assign it here!\n  };\n\n  return request({ method, path, data: { job } })(state);\n});\n",
          "adaptor": "@openfn/language-openfn@v1.1.4",
          "project_credential_id": null
        },
        "A3-Generate-SQL-to-setup-DB-AUTO---MSSQL": {
          "id": "6946277d-c9cd-45bd-917b-a3f9de1fab2b",
          "name": "A3 Generate SQL to setup DB AUTO - MSSQL",
          "body": "// Here we set default options for the SQL adaptor. Setting execute or writeSql\n// below will set the standard behavior of all SQL functions below unless overwritten.\n\n//SET execute: true  if you want to SQL script to be auto-executed in the DB linked to this job \n//SET execute: false if you do NOT want to execure the SQL script, and only wnat to generate the script (see \"writeSql\")\nfn(state => ({ ...state, execute: false, writeSql: true }));\n\n// Creates tables in the db.\neach(\n  '$.tables[*]',\n  fn(state => {\n    const { execute, writeSql } = state;\n    const { name, defaultColumns } = state.data;\n\n    function convertToMssqlTypes(col) {\n      col.type = col.referent\n        ? 'int'\n        : col.type === 'select_one' ||\n          col.type === 'select_multiple' ||\n          col.type === 'text' ||\n          col.type === 'jsonb'\n        ? 'nvarchar(max)'\n        : col.type.includes('varchar')\n        ? col.type.replace('varchar', 'nvarchar')\n        : col.type === 'int4' || col.type === 'float4'\n        ? col.type.substring(0, col.type.length - 1)\n        : col.type === 'timestamp'\n        ? 'datetime'\n        : col.type;\n\n      if (col.type === 'datetime') col.default = 'GETDATE()';\n    }\n\n    function insert(name, columns, execute, writeSql, state) {\n      columns.forEach(col => convertToMssqlTypes(col));\n      return insertTable(name, state => columns, {\n        writeSql,\n        execute,\n      })(state).then(state => {\n        if (defaultColumns) {\n          let foreignKeyQueries = [];\n          if (state.data.foreignTables) {\n            const { foreignTables } = state.data;\n            for (let ft of foreignTables) {\n              const { table, id, reference } = ft;\n              foreignKeyQueries.push(`ALTER TABLE ${name} WITH CHECK ADD CONSTRAINT FK_${name}_${\n                reference ? reference : id\n              } FOREIGN KEY (${reference ? reference : id})\n              REFERENCES ${table} (${id});\n              ALTER TABLE ${name} CHECK CONSTRAINT FK_${name}_${\n                reference ? reference : id\n              };`);\n            }\n          }\n          // Creating foreign keys constraints to standard WCS DB and fields\n          return sql({\n            query: state =>\n              `ALTER TABLE ${name} WITH CHECK ADD CONSTRAINT FK_${name}_OrganizationID_Owner FOREIGN KEY (${\n                state.prefixes\n              }OrganizationID_Owner)\n            REFERENCES WCSPROGRAMS_Organization (WCSPROGRAMS_OrganizationID);\n            ALTER TABLE ${name} CHECK CONSTRAINT FK_${name}_OrganizationID_Owner;\n            ALTER TABLE ${name} WITH CHECK ADD CONSTRAINT FK_${name}_SecuritySettingID_Row FOREIGN KEY (${\n                state.prefixes\n              }SecuritySettingID_Row)\n            REFERENCES WCSPROGRAMS_SecuritySetting (WCSPROGRAMS_SecuritySettingID);\n            ALTER TABLE ${name} CHECK CONSTRAINT FK_${name}_SecuritySettingID_Row;\n            ${foreignKeyQueries.join('\\n')}\n          `,\n            options: {\n              writeSql: true, // Keep to true to log query (otherwise make it false).\n              execute: false, // keep to false to not alter DB\n            },\n          })(state);\n        }\n        return state;\n      });\n    }\n\n    function modify(name, newColumns, execute, writeSql, state) {\n      if (newColumns && newColumns.length > 0) {\n        console.log('Existing table found in mssql --- Updating.');\n        // Note: Specify options here (e.g {writeSql: false, execute: true})\n        return modifyTable(name, state => newColumns, {\n          writeSql, // Keep to true to log query (otherwise make it false).\n          execute, // keep to false to not alter DB\n        })(state);\n      } else {\n        console.log('No new columns to add.');\n        return state;\n      }\n    }\n\n    if (name !== `${state.prefixes}_Untitled`) {\n      let mergedColumns = state.data.columns;\n      if (state.data.defaultColumns)\n        mergedColumns = [...state.data.columns, ...state.data.defaultColumns];\n\n      return describeTable(name.toLowerCase(), {\n        writeSql: true, // Keep to true to log query.\n        execute, // Keep to true to execute query.\n      })(state)\n        .then(resp => {\n          const { rows } = resp.response.body;\n          if (resp.response.body.rowCount === 0) {\n            console.log('No matching table found in mssql --- Inserting.');\n            const columns = mergedColumns.filter(x => x.name !== undefined);\n\n            // change this line to 'return insert(name, columns, true, writeSql, state);' to override 'execute: false' at top\n            return insert(name, columns, execute, writeSql, state);\n          } else {\n            const columnNames = rows.map(x => x.column_name.toLowerCase());\n\n            console.log('----------------------');\n            const newColumns = mergedColumns.filter(\n              x =>\n                x.name !== undefined &&\n                !columnNames.includes(x.name.toLowerCase())\n            );\n            newColumns.forEach(col => convertToMssqlTypes(col));\n            console.log(newColumns);\n\n            // change this line to 'return modify(name, newColumns, true, writeSql, state);' to override 'execute: false' at top\n            return modify(name, newColumns, execute, writeSql, state);\n          }\n        })\n        .catch(() => {\n          // If describeTable does NOT get executed because they've turned off execute,\n          // we should write the SQL for all the insert statements without executing them.\n          const columns = mergedColumns.filter(x => x.name !== undefined);\n          return insert(name, columns, execute, writeSql, state);\n        });\n    }\n    return state;\n  })\n);\n\n// Adds \"seeds\" to the lookup tables—rows that can be referenced in submissions.\neach(\n  '$.seeds[*]',\n  fn(state => {\n    const { writeSql, execute, data } = state;\n    const { table, externalId, records } = data;\n    return upsertMany(\n      table, // table name\n      externalId, // external ID column name\n      state => {\n        // array of records to upsert\n        return records.map(r => ({\n          [externalId]: r,\n          [`${table}Name`]: r,\n        }));\n      },\n      { writeSql, execute, logValues: true } // options\n    )(state);\n  })\n);\n\n// Prints out SQL statements for manual inspection and work.\nfn(state => {\n  console.log('----------------------');\n  console.log('Logging queries.');\n  for (query of state.queries) console.log(query);\n  console.log('----------------------');\n\n  return state;\n});\n",
          "adaptor": "@openfn/language-mssql@v3.0.0",
          "project_credential_id": null
        },
        "A5-Prepare-Form-for-Data-Dictionary-AUTO---MSSQL": {
          "id": "ef1f89eb-6b95-48d8-b7f9-1e5ddd1dd044",
          "name": "A5 Prepare Form for Data Dictionary AUTO - MSSQL",
          "body": "fn(state => {\n  const KoboToolBox_Forms = [\n    {\n      name: 'form_name',\n      type: 'nvarchar(100)',\n    },\n    {\n      name: 'date_created',\n      type: 'date',\n    },\n    {\n      name: 'date_modified',\n      type: 'date',\n    },\n    {\n      name: 'form_owner',\n      type: 'nvarchar(100)',\n    },\n    {\n      name: 'languages',\n      type: 'nvarchar(100)',\n    },\n    {\n      name: 'form_id',\n      type: 'nvarchar(100)',\n      unique: true,\n    },\n    {\n      name: 'form_group',\n      type: 'nvarchar(100)',\n    },\n    {\n      name: 'table_id',\n      type: 'nvarchar(100)',\n    },\n  ];\n\n  const KoboToolBox_Questions = [\n    {\n      name: 'question_id',\n      type: 'nvarchar(100)',\n      unique: true,\n    },\n    {\n      name: 'form_id',\n      type: 'nvarchar(100)',\n    },\n    {\n      name: 'analytics_label',\n      type: 'nvarchar(max)',\n    },\n    {\n      name: 'question_name',\n      type: 'nvarchar(max)',\n    },\n    {\n      name: 'label',\n      type: 'nvarchar(max)',\n    },\n    {\n      name: 'question_type',\n      type: 'nvarchar(100)',\n    },\n    {\n      name: 'list_id',\n      type: 'nvarchar(100)',\n    },\n    {\n      name: 'question_constraint',\n      type: 'nvarchar(max)',\n    },\n  ];\n\n  const KoboToolBox_Choices = [\n    {\n      name: 'choice_id',\n      type: 'nvarchar(100)',\n      unique: true,\n    },\n    {\n      name: 'list_id',\n      type: 'nvarchar(100)',\n    },\n    {\n      name: 'list_name',\n      type: 'nvarchar(100)',\n    },\n    {\n      name: 'choice_name',\n      type: 'nvarchar(100)',\n    },\n    {\n      name: 'choice_label',\n      type: 'nvarchar(max)',\n    },\n    {\n      name: 'form_uid',\n      type: 'nvarchar(100)',\n    },\n  ];\n\n  const MetadataForms = [\n    {\n      name: 'KoboToolBox_Forms',\n      columns: KoboToolBox_Forms,\n    },\n    {\n      name: 'KoboToolBox_Questions',\n      columns: KoboToolBox_Questions,\n    },\n    {\n      name: 'KoboToolBox_Choices',\n      columns: KoboToolBox_Choices,\n    },\n  ];\n\n  return { ...state, MetadataForms };\n});\n\neach(\n  '$.MetadataForms[*]',\n  fn(state => {\n    const { name, columns } = state.data;\n    \n    function insert(name, columns, execute, writeSql, state) {\n      columns.forEach(col =>\n        col.type === 'select_one' || col.type === 'select_multiple'\n          ? (col.type = 'nvarchar(max)')\n          : col.type\n      );\n      return insertTable(name, state => columns, {\n        writeSql,\n        execute,\n      })(state);\n    }\n\n    function modify(name, newColumns, execute, writeSql, state) {\n      newColumns.forEach(col =>\n        col.type === 'select_one' || col.type === 'select_multiple'\n          ? (col.type = 'nvarchar(max)')\n          : col.type\n      );\n      if (newColumns && newColumns.length > 0) {\n        console.log('Existing table found in mssql --- Updating.');\n        // Note: Specify options here (e.g {writeSql: false, execute: true})\n        return modifyTable(name, state => newColumns, {\n          writeSql, // Keep to true to log query (otherwise make it false).\n          execute, // keep to false to not alter DB\n        })(state);\n      } else {\n        console.log('No new columns to add.');\n        return state;\n      }\n    }\n\n    // Note: Specify options here\n    const execute = false;\n    const writeSql = true;\n\n    return describeTable(name.toLowerCase(), {\n      writeSql: true,\n      execute,\n    })(state)\n      .then(mssqlColumn => {\n        const { rows } = mssqlColumn.response.body;\n        if (mssqlColumn.response.body.rowCount === 0) {\n          console.log('No matching table found in mssql --- Inserting.');\n\n          const cols = columns.filter(x => x.name !== undefined);\n          return insert(name, cols, execute, writeSql, state);\n        } else {\n          const columnNames = rows.map(x => x.column_name);\n\n          console.log('----------------------');\n          const newColumns = columns.filter(\n            x =>\n              x.name !== undefined &&\n              !columnNames.includes(x.name.toLowerCase())\n          );\n\n          console.log(newColumns);\n          return modify(name, newColumns, execute, writeSql, state);\n        }\n      })\n      .catch(() => {\n        return insert(name, columns, execute, writeSql, state);\n      });\n  })\n);\n\nfn(state => {\n  const { openfnInboxUrl } = state.configuration;\n  const data = {\n    type: 'Form Definition',\n    formDefinition: state.formDefinition,\n    prefixes: state.prefixes,\n    prefix2: state.prefix2,\n    tableId: state.tableId,\n  };\n  console.log('Sending form definition to OpenFN inbox.');\n  http.post({\n    url: openfnInboxUrl,\n    data,\n    maxContentLength: Infinity,\n    maxBodyLength: Infinity,\n  })(state);\n\n  return state;\n});\n\nfn(state => {\n  console.log('----------------------');\n  console.log('Logging queries.');\n  for (query of state.queries) console.log(query);\n  console.log('----------------------');\n  return state;\n});\n",
          "adaptor": "@openfn/language-mssql@v2.6.4",
          "project_credential_id": null
        }
      },
      "edges": {
        "webhook->A2-Process-Forms-AUTO": {
          "enabled": true,
          "id": "e24c3cbb-792a-46a0-b9e6-c7657b997884",
          "target_job_id": "ea64cfd3-401d-4c36-a708-a4aa89ea4f05",
          "source_trigger_id": "ec90e89e-9fd3-4d26-ab9f-df0dc01a0629",
          "condition_type": "js_expression",
          "condition_label": "Form Changed",
          "condition_expression": "state.data.formUpdate == true"
        },
        "A2-Process-Forms-AUTO->A4-Generate-OpenFn-Job-script-AUTO---OPENFN-JOB": {
          "enabled": true,
          "id": "25cd6c6d-95d0-4979-840f-b630f6383e8d",
          "target_job_id": "ddcb3bd8-a268-4f74-bae5-8b1c203244cb",
          "source_job_id": "ea64cfd3-401d-4c36-a708-a4aa89ea4f05",
          "condition_type": "on_job_success"
        },
        "A2-Process-Forms-AUTO->A3-Generate-SQL-to-setup-DB-AUTO---MSSQL": {
          "enabled": true,
          "id": "8fd938dd-68d7-4d7c-8dd2-71242cb8059c",
          "target_job_id": "6946277d-c9cd-45bd-917b-a3f9de1fab2b",
          "source_job_id": "ea64cfd3-401d-4c36-a708-a4aa89ea4f05",
          "condition_type": "on_job_success"
        },
        "A2-Process-Forms-AUTO->A5-Prepare-Form-for-Data-Dictionary-AUTO---MSSQL": {
          "enabled": true,
          "id": "88500546-709d-49ec-b022-6e2fa89342bb",
          "target_job_id": "ef1f89eb-6b95-48d8-b7f9-1e5ddd1dd044",
          "source_job_id": "ea64cfd3-401d-4c36-a708-a4aa89ea4f05",
          "condition_type": "on_job_success"
        }
      }
    },
    "auto-WCSPROGRAMS-CameraKoboDeployment": {
      "id": "cee12916-442b-4de6-8ae6-bbf71864808e",
      "name": "auto  WCSPROGRAMS CameraKoboDeployment",
      "inserted_at": "2025-03-18T09:53:05.879518Z",
      "lock_version": 6,
      "triggers": {
        "webhook": {
          "enabled": false,
          "id": "01b1fb36-9cea-406f-9e6d-8127af9122e2",
          "type": "webhook"
        }
      },
      "jobs": {
        "auto-WCSPROGRAMS-CameraKoboDeployment": {
          "id": "0a39810b-56fe-4d99-a30a-65ca94309e16",
          "name": "auto WCSPROGRAMS CameraKoboDeployment",
          "body": "fn(state => {\n    const multiSelectIds = [\"\"];\n\n    function generateUuid(body, uuid) {\n      for (const property in body) {\n        if (Array.isArray(body[property]) && body !== null) {\n          body['__generatedUuid'] = uuid;\n          body[property].forEach((thing, i, arr) => {\n            if (thing !== null) {\n              thing['__parentUuid'] = uuid;\n              let newUuid = uuid + '-' + (i + 1);\n              thing['__generatedUuid'] = newUuid;\n              for (const property in thing) {\n                if (Array.isArray(thing[property])) {\n                  generateUuid(thing, newUuid);\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n\n    generateUuid(\n      state.data.body,\n      state.data.body._id+'-'+state.data.body._xform_id_string\n    );\n\n    const { body } = state.data;\n    const { _id, _xform_id_string } = body;\n    state.data = { ...state.data, ...body };\n\n    return { ...state, _id, _xform_id_string };\n  }); \nfn(async state => {\n const mapping = {\n  FormName: dataValue('formName'),\n  DatasetId: dataValue('_xform_id_string'),\n  LastUpdated: new Date().toISOString()\n} \n return upsert('WCSPROGRAMS_KoboDataset', \"DatasetId\", mapping, {setNull: [\"''\", \"'undefined'\"]})(state); \n}) \nfn(async state => {\n const mapping = {\n  Note: dataValue('note'),\n  Battery: dataValue('battery'),\n  WCSPROGRAMS_CameraKoboYesNoID_KeyRetrieved: await findValue({uuid: 'wcsprograms_camerakoboyesnoid', relation: 'WCSPROGRAMS_CameraKoboYesNo', where: { WCSPROGRAMS_CameraKoboYesNoExtCode: dataValue('key_retrieved') }})(state),\n  WCSPROGRAMS_CameraKoboYesNoID_MotionTest: await findValue({uuid: 'wcsprograms_camerakoboyesnoid', relation: 'WCSPROGRAMS_CameraKoboYesNo', where: { WCSPROGRAMS_CameraKoboYesNoExtCode: dataValue('motion_test') }})(state),\n  WCSPROGRAMS_CameraKoboYesNoID_CameraOn: await findValue({uuid: 'wcsprograms_camerakoboyesnoid', relation: 'WCSPROGRAMS_CameraKoboYesNo', where: { WCSPROGRAMS_CameraKoboYesNoExtCode: dataValue('camera_on') }})(state),\n  WCSPROGRAMS_CameraKoboYesNoID_SdInsert: await findValue({uuid: 'wcsprograms_camerakoboyesnoid', relation: 'WCSPROGRAMS_CameraKoboYesNo', where: { WCSPROGRAMS_CameraKoboYesNoExtCode: dataValue('sd_insert') }})(state),\n  WCSPROGRAMS_CameraKoboYesNoID_SdUnlock: await findValue({uuid: 'wcsprograms_camerakoboyesnoid', relation: 'WCSPROGRAMS_CameraKoboYesNo', where: { WCSPROGRAMS_CameraKoboYesNoExtCode: dataValue('sd_unlock') }})(state),\n  NoKey: dataValue('no_key'),\n  SdCard: dataValue('sd_card'),\n  DetectionDistance: dataValue('detection_distance'),\n  PlotTreatmentDescription: dataValue('plot_treatment_description'),\n  PlotTreatment: dataValue('plot_treatment'),\n  RecordedBy: dataValue('recorded_by'),\n  OrientationOther: dataValue('orientation_other'),\n  Direction: dataValue('direction'),\n  WCSPROGRAMS_CameraKoboAngleID_SensorOrientation: await findValue({uuid: 'wcsprograms_camerakoboangleid', relation: 'WCSPROGRAMS_CameraKoboAngle', where: { WCSPROGRAMS_CameraKoboAngleExtCode: dataValue('sensor_orientation') }})(state),\n  HeightOther: dataValue('height_other'),\n  CmHeight: dataValue('cm_height'),\n  WCSPROGRAMS_CameraKoboHeightID_SensorHeight: await findValue({uuid: 'wcsprograms_camerakoboheightid', relation: 'WCSPROGRAMS_CameraKoboHeight', where: { WCSPROGRAMS_CameraKoboHeightExtCode: dataValue('sensor_height') }})(state),\n  QuietPeriod: dataValue('quiet_period'),\n  FeatureTypeMethodology: dataValue('feature_type_methodology'),\n  WCSPROGRAMS_CameraKoboFeatureID_FeatureType: await findValue({uuid: 'wcsprograms_camerakobofeatureid', relation: 'WCSPROGRAMS_CameraKoboFeature', where: { WCSPROGRAMS_CameraKoboFeatureExtCode: dataValue('feature_type') }})(state),\n  BaitDescription: dataValue('bait_description'),\n  WCSPROGRAMS_CameraKoboBaitID_BaitType: await findValue({uuid: 'wcsprograms_camerakobobaitid', relation: 'WCSPROGRAMS_CameraKoboBait', where: { WCSPROGRAMS_CameraKoboBaitExtCode: dataValue('bait_type') }})(state),\n  WCSPROGRAMS_CameraKoboEventID_EventType: await findValue({uuid: 'wcsprograms_camerakoboeventid', relation: 'WCSPROGRAMS_CameraKoboEvent', where: { WCSPROGRAMS_CameraKoboEventExtCode: dataValue('event_type') }})(state),\n  EventDescription: dataValue('event_description'),\n  EventName: dataValue('event_name'),\n  StartDate: dataValue('start_date'),\n  WCSPROGRAMS_CameraKoboCanopyID_Canopy: await findValue({uuid: 'wcsprograms_camerakobocanopyid', relation: 'WCSPROGRAMS_CameraKoboCanopy', where: { WCSPROGRAMS_CameraKoboCanopyExtCode: dataValue('canopy') }})(state),\n  WCSPROGRAMS_CameraKoboVisibilityID_Visibility: await findValue({uuid: 'wcsprograms_camerakobovisibilityid', relation: 'WCSPROGRAMS_CameraKoboVisibility', where: { WCSPROGRAMS_CameraKoboVisibilityExtCode: dataValue('visibility') }})(state),\n  WCSPROGRAMS_CameraKoboUnderwoodID_Underwood: await findValue({uuid: 'wcsprograms_camerakobounderwoodid', relation: 'WCSPROGRAMS_CameraKoboUnderwood', where: { WCSPROGRAMS_CameraKoboUnderwoodExtCode: dataValue('underwood') }})(state),\n  WCSPROGRAMS_CameraKoboSlopeID_Slope: await findValue({uuid: 'wcsprograms_camerakoboslopeid', relation: 'WCSPROGRAMS_CameraKoboSlope', where: { WCSPROGRAMS_CameraKoboSlopeExtCode: dataValue('slope') }})(state),\n  WCSPROGRAMS_CameraKoboVegID_Veg: await findValue({uuid: 'wcsprograms_camerakobovegid', relation: 'WCSPROGRAMS_CameraKoboVeg', where: { WCSPROGRAMS_CameraKoboVegExtCode: dataValue('veg') }})(state),\n  Latitude: state => state.data.gps.split(' ')[0],\n  Longitude: state => state.data.gps.split(' ')[1],\n  WCSPROGRAMS_CameraKoboCameraID_CameraId: await findValue({uuid: 'wcsprograms_camerakobocameraid', relation: 'WCSPROGRAMS_CameraKoboCamera', where: { WCSPROGRAMS_CameraKoboCameraExtCode: dataValue('camera_id') }})(state),\n  PointTransect: dataValue('point_transect'),\n  TeamLead: dataValue('team_lead'),\n  Placename: dataValue('placename'),\n  SubprojectDesign: dataValue('subproject_design'),\n  SubprojectName: dataValue('subproject_name'),\n  ProjectId: dataValue('project_id'),\n  DeploymentId: dataValue('deployment_id'),\n  Deviceid: dataValue('deviceid'),\n  Today: dataValue('today'),\n  FormDateEnd: dataValue('end'),\n  Start: dataValue('start'),\n  AnswerId: state._id,\n  GeneratedUuid: dataValue('__generatedUuid'),\n  Payload: state.data.body\n} \n return upsert('WCSPROGRAMS_CameraKoboDeployment', 'GeneratedUuid', mapping, {setNull: [\"''\", \"'undefined'\"]})(state); \n}) \n",
          "adaptor": "@openfn/language-mssql@v2.6.11",
          "project_credential_id": null
        }
      },
      "edges": {
        "webhook->auto-WCSPROGRAMS-CameraKoboDeployment": {
          "enabled": false,
          "id": "89c8c45b-12d2-4a22-86ff-74043de6447d",
          "target_job_id": "0a39810b-56fe-4d99-a30a-65ca94309e16",
          "source_trigger_id": "01b1fb36-9cea-406f-9e6d-8127af9122e2",
          "condition_type": "js_expression",
          "condition_label": "auto/WCSPROGRAMS_CameraKoboDeployment",
          "condition_expression": "state.data.tableId == \"WCSPROGRAMS_CameraKoboDeployment\""
        }
      }
    },
    "z[Archive]-Query-DB-KoboData-Table---Test": {
      "id": "bb519a8e-eecc-4a23-8367-6330aab2c63f",
      "name": "z[Archive] Query DB KoboData Table - Test",
      "inserted_at": "2025-03-18T09:53:25.503446Z",
      "lock_version": 7,
      "triggers": {
        "cron": {
          "enabled": false,
          "id": "5947835a-54fc-4b6f-b4e8-7f7efe118a95",
          "type": "cron",
          "cron_expression": "0 */1 * * *"
        }
      },
      "jobs": {
        "Query-DB-KoboData-Table---Test": {
          "id": "73f7360d-7ed1-445a-89d1-5fa8d91498cf",
          "name": "Query DB KoboData Table - Test",
          "body": "sql({ query: state =>\n    `SELECT * FROM WCSPROGRAMS_KoboData where DatasetUuidId = 'BNS NDOKI 2022-aRnpV9xNVcbqLPbmoKn9sR'`,\n}, state => {\n  console.log(state); \n  return state; \n});\n\nfn(state => {\n  console.log(JSON.stringify(state.response.rows, null,2)); \n  return state; \n})\n",
          "adaptor": "@openfn/language-mssql@v4.0.7",
          "project_credential_id": null
        }
      },
      "edges": {
        "cron->Query-DB-KoboData-Table---Test": {
          "enabled": true,
          "id": "c68956a7-ccbd-4649-98de-29f5cbeadfdc",
          "target_job_id": "73f7360d-7ed1-445a-89d1-5fa8d91498cf",
          "source_trigger_id": "5947835a-54fc-4b6f-b4e8-7f7efe118a95",
          "condition_type": "always"
        }
      }
    },
    "4.-FS1---Get-Forms": {
      "id": "cc58f66e-143e-43da-8f62-8225b9258bd5",
      "name": "4. FS1 - Get Forms",
      "inserted_at": "2025-03-18T09:53:34.126170Z",
      "lock_version": 14,
      "triggers": {
        "cron": {
          "enabled": false,
          "id": "f2d20419-c117-42b7-8c01-7366b82060ef",
          "type": "cron",
          "cron_expression": "0 2 * * *"
        }
      },
      "jobs": {
        "FS1---Get-Forms": {
          "id": "6e03d604-ca33-4547-b6d1-5cdbd7b2fe1b",
          "name": "FS1 - Get Forms",
          "body": "//Check Kobo account for forms with these matching keywords\ngetForms({}, state => {\n  //ALL KEYWORDS:\n  //const keywords = ['price', 'prix', 'bns', 'nrgt', 'grm', 'feedback'];\n\n  //BNS KEYWORDS ONLY\n  const keywords = ['price', 'prix', 'bns', 'nrgt'];\n\n  const checkForKeyWords = name => {\n    return keywords.some(keyword => name.toLowerCase().includes(keyword));\n  };\n\n  state.activeForms = state.data.results\n    .filter(form => checkForKeyWords(form.name))\n    .filter(form => form.deployment__active);\n\n  state.archivedForms = state.data.results\n    .filter(form => checkForKeyWords(form.name))\n    .filter(form => !form.deployment__active);\n    \n  console.log('# of activeForms ::', state.activeForms ? state.activeForms.length : null );\n  console.log('# of archivedForms ::', state.archivedForms ? state.archivedForms.length : null );\n\n  state.data = {};\n  state.references = [];\n  return state;\n});\n",
          "adaptor": "@openfn/language-kobotoolbox@2.1.0",
          "project_credential_id": "950c9c55-fb89-4d8c-ab24-e2ca04a38ba7"
        },
        "FS2---Get-List-from-Sheets": {
          "id": "baf76774-7aff-41e6-a2f8-db557595e423",
          "name": "FS2 - Get List from Sheets",
          "body": "getValues(\n  '1xexwj6HKJGHJM-sOzIOGqPHolgpdnp0GmjMIXwoV7OE', //googlesheet id\n  'wcs-bns-DEPLOYED!A:O' //range of columns in sheet\n);\nfn(state => {\n  const { activeForms, archivedForms, data } = state;\n  const [headers, ...sheetsData] = data.values;\n  const sheetsUids = sheetsData.map(row => row[0]);\n  console.log('Ignoring headers', headers);\n\n  state.formsToCreate = activeForms.filter(\n    form => !sheetsUids.includes(form.uid)\n  );\n\n  state.formsToUpdate = archivedForms\n    .filter(form => sheetsUids.includes(form.uid))\n    .map(form => {\n      const rowIndex = sheetsData.findIndex(row => {\n        return row[0] === form.uid;\n      });\n      if (rowIndex !== -1) {\n        return { ...form, rowIndex };\n      }\n      console.log(form.uid, 'Could not be found in google sheet');\n    });\n\n  return state;\n});\n\nfn(state => {\n  const { data, references, response, ...remainingState } = state;\n\n  return remainingState;\n});\n",
          "adaptor": "@openfn/language-googlesheets@2.4.0",
          "project_credential_id": "8f098581-1fba-449e-b7e5-49d7e8edc66b"
        },
        "FS3---Find-New-Forms-Shared": {
          "id": "dec99f73-9804-4cd6-ac33-bd8ac65338d0",
          "name": "FS3 - Find New Forms Shared",
          "body": "//Compare new forms in Kobo with GoogleSheet list to see if new forms were shared in Kobo\nfn(state => {\n  const { formsToCreate, formsToUpdate } = state;\n  const keywords = ['price', 'prix', 'bns', 'nrgt', 'grm', 'feedback'];\n\n  const tagMapping = {\n    price: 'bns_price',\n    prix: 'bns_price',\n    bns: 'bns_survey',\n    nrgt: 'nrgt_current',\n    grm: 'grm',\n    feedback: 'grm',\n  };\n\n  const createTagName = name => {\n    let tag = '';\n    const keyword = keywords.find(keyword =>\n      name.toLowerCase().includes(keyword)\n    );\n\n    if (keyword) {\n      tag = tagMapping[keyword] || keyword;\n    }\n    return tag;\n  };\n\n  const containsGRMFeedback = name =>\n    !name.toLowerCase().includes('grm', 'feedback');\n\n  const instance = name =>\n    containsGRMFeedback(name) ? 'ADD MANUALLY @Admin!' : '';\n\n  const projectId = name =>\n    containsGRMFeedback(name) ? 'ADD MANUALLY @Admin!' : '';\n\n  const grmID = name => (containsGRMFeedback(name) ? 'GRM ID. XX' : '');\n\n  const workspaceName = name =>\n    containsGRMFeedback(name) ? 'Grievances' : 'ConSoSci';\n    \n  state.formLastModified = form => form.date_modified; \n\n  const sheetRowMap = form => [\n    form.uid,\n    form.name,\n    createTagName(form.name),\n    form.owner__username,\n    instance(form.name),\n    //projectId(form.name), //for GRM only\n    //grmID(form.name), //for GRM only\n    form.deployment__active ? 'deployed' : 'archived', //deployment status //if we assume only deployed forms will be fetched\n    'ConSoSci', //openfn project space --> OLD dynamic mapping: //workspaceName(form.name),\n    `https://kf.kobotoolbox.org/#/forms/${form.url}/summary`, //form.url,\n    form.date_modified, //kobo_form_date_modified\n    form.date_created, //kobo_form_date_created\n    new Date().toISOString(), //row_date_modified\n    false, //auto_sync checkbox\n    //job code template\n    `\"{id: '${form.uid}', tag: '${createTagName(form.name)}', name: '${\n      form.name\n    }', owner: '${form.owner__username}', instance: '${instance(form.name)}'},\"`,\n  ];\n\n  state.rowValuesToCreate = formsToCreate.map(form => sheetRowMap(form));\n  state.rowValuesToUpdate = formsToUpdate.map(form => ({\n    range: `wcs-bns-DEPLOYED!A${form.rowIndex + 2}:N${form.rowIndex + 2}`,\n    values: [sheetRowMap(form)],\n  }));\n  state.rowValuesToArchive = formsToUpdate.map(form => sheetRowMap(form));\n\n  console.log('# of new forms detected:: ', state.rowValuesToCreate.length);\n  console.log('Forms to add to the master sheet:: ', state.rowValuesToCreate);\n  return state;\n});\n\n//if new Kobo form shared, adding to the \"Deployed\"\" Sheet...\nappendValues({\n  spreadsheetId: '1s7K3kxzm5AlpwiALattyc7D9_aIyqWmo2ubcQIUlqlY', //sheet id\n  range: 'wcs-bns-DEPLOYED!A:O', //range of columns in sheet\n  values: state => state.rowValuesToCreate,\n});\n\n//updating rows in Sheet where forms are archived\neach(\n  '$.rowValuesToUpdate[*]',\n  batchUpdateValues({\n    spreadsheetId: '1s7K3kxzm5AlpwiALattyc7D9_aIyqWmo2ubcQIUlqlY', //sheet id\n    range: state => state.data.range, //range of columns in sheet\n    values: state => state.data.values,\n  })\n);\n\n//also adding archived rows to \"Archived\" Sheet...\nappendValues({\n  spreadsheetId: '1s7K3kxzm5AlpwiALattyc7D9_aIyqWmo2ubcQIUlqlY', //sheet id\n  range: 'wcs-bns-ARCHIVED!A:O', //range of columns in sheet\n  values: state => state.rowValuesToArchive,\n});\n",
          "adaptor": "@openfn/language-googlesheets@2.4.0",
          "project_credential_id": "8f098581-1fba-449e-b7e5-49d7e8edc66b"
        },
        "FS4---Notify-in-Asana": {
          "id": "b72847b2-dd6a-42d7-a9d8-e87a6a227695",
          "name": "FS4 - Notify in Asana",
          "body": "//This job will add a task to Asana if a new Kobo form was shared\nfn(state => {\n  console.log('formLastModifiedDate:: ', state.formLastModified); \n  const dueDate = new Date(new Date().getTime() + 5 * 24 * 60 * 60 * 1000)\n    .toISOString()\n    .split('T')[0];\n\n  state.asanaTasks = state.activeForms.map(form => {\n    return {\n      name: `New form added to OpenFn: ${form.name}`,\n      approval_status: 'pending',\n      projects: ['1198901998266253'],\n      assignee_section: '1207247884457665', //OLD General Section: '1203181218738601',\n      assignee: '1208302456826465',\n      due_on: dueDate,\n      notes: `New form added to OpenFn: ${form.name} (uid: ${form.uid}). Please review the Google Sheet to (1) update columns L, N, & O, and (2) update column E (look for cells where it says \"ADD MANUALLY\" to add any values missing e.g., \"Instance\"): https://docs.google.com/spreadsheets/d/1s7K3kxzm5AlpwiALattyc7D9_aIyqWmo2ubcQIUlqlY/edit#gid=1559623602`,\n    };\n  });\n\n  state.archivedFormsTasks = state.archivedForms.map(form => {\n    return {\n      name: `Form archived: ${form.name}`,\n      projects: ['1198901998266253'],\n      assignee_section: '1207247884457665', //OLD General Section: '1203181218738601',\n      assignee: '1208302456826465',\n      due_on: dueDate,\n      notes: `Kobo form was archived: ${form.name} (uid: ${form.uid}). Please review the Google Sheet to (1) confirm this is correct, (2) remove from the \"Deployed\" sheet if you want to remove from the OpenFn Sync, and (3) update notes in the \"Archived\" sheet: https://docs.google.com/spreadsheets/d/1s7K3kxzm5AlpwiALattyc7D9_aIyqWmo2ubcQIUlqlY/edit#gid=1559623602`,\n    };\n  });\n\n  console.log('# of New Form Asana Tasks to add:: ', state.asanaTasks.length);\n  console.log('New form alert tasks to upsert:: ', state.asanaTasks);\n  console.log(\n    '# of Archibed Form Asana Tasks to add:: ',\n    state.archivedFormsTasks.length\n  );\n  console.log(\n    'Archived form alert tasks to upsert:: ',\n    state.archivedFormsTasks\n  );\n  return state;\n});\n\n//upsert Asana task if new form shared notification needed\neach(\n  '$.asanaTasks[*]',\n  upsertTask('1198901998266253', {\n    //project_id\n    externalId: 'name',\n    data: state => state.data,\n  })\n);\n\neach(\n  '$.archivedFormsTasks[*]',\n  upsertTask('1198901998266253', {\n    //project_id\n    externalId: 'name',\n    data: state => state.data,\n  })\n);\n",
          "adaptor": "@openfn/language-asana@latest",
          "project_credential_id": "4eb4c277-68ae-4d71-a569-3584b2cc4719"
        }
      },
      "edges": {
        "cron->FS1---Get-Forms": {
          "enabled": true,
          "id": "21dbd800-bb57-4164-8b76-82d2b650ea37",
          "target_job_id": "6e03d604-ca33-4547-b6d1-5cdbd7b2fe1b",
          "source_trigger_id": "f2d20419-c117-42b7-8c01-7366b82060ef",
          "condition_type": "always"
        },
        "FS1---Get-Forms->FS2---Get-List-from-Sheets": {
          "enabled": true,
          "id": "7d5485c9-82c3-40cd-9fed-66f9a294cbc5",
          "target_job_id": "baf76774-7aff-41e6-a2f8-db557595e423",
          "source_job_id": "6e03d604-ca33-4547-b6d1-5cdbd7b2fe1b",
          "condition_type": "on_job_success"
        },
        "FS2---Get-List-from-Sheets->FS3---Find-New-Forms-Shared": {
          "enabled": true,
          "id": "e61859ca-20ba-4a4d-88de-bb6dcf35dd23",
          "target_job_id": "dec99f73-9804-4cd6-ac33-bd8ac65338d0",
          "source_job_id": "baf76774-7aff-41e6-a2f8-db557595e423",
          "condition_type": "on_job_success"
        },
        "FS3---Find-New-Forms-Shared->FS4---Notify-in-Asana": {
          "enabled": false,
          "id": "51b306a5-092c-4e9a-af08-ba9208b4eebe",
          "target_job_id": "b72847b2-dd6a-42d7-a9d8-e87a6a227695",
          "source_job_id": "dec99f73-9804-4cd6-ac33-bd8ac65338d0",
          "condition_type": "on_job_success"
        }
      }
    },
    "z[Archive]-Get-Kobo-Forms-Template": {
      "id": "03a44f85-242f-4cdf-b210-27ae88c8c2fc",
      "name": "z[Archive] Get Kobo Forms Template",
      "inserted_at": "2025-03-18T09:53:48.566932Z",
      "lock_version": 6,
      "triggers": {
        "cron": {
          "enabled": false,
          "id": "cdeb0670-9b39-4f5c-a9a9-e11b8ec0ccf7",
          "type": "cron",
          "cron_expression": "0 */1 * * *"
        }
      },
      "jobs": {
        "Get-Kobo-Forms-Template": {
          "id": "ef2461bd-6de4-4994-b526-334f6a03917b",
          "name": "Get Kobo Forms Template",
          "body": "fn(state => {\n  console.log('Current cursor value:', state.lastEnd);\n\n  // IF YOU CLEAR STATE...\n  // Set this manual cursor to the earliest submission date you want fetch.\n  const manualCursor = '2022-04-10T14:32:43.325+01:00';\n  state.data = {\n    surveys: [\n    //==== GRIEVENCES FORM ===============//\n     {\n       uid: 'aEQjRDMcEgLzRDQYcFqSCC',\n       formName: 'SSMT GRM Intake Form Template', //Kobo form name\n       projectid: '1201382240883590' //Asana project ID obtained from the Fetch Asana ID job.\n     },\n    // {\n    //   uid: 'aEQjRDMcEgLzRDQYcFqSCC',\n    //   formName: 'SSMT GRM Intake Form Template', //Kobo form name\n    //   projectid: '1201871867457230' // Asana project ID: Indonesia GRM\n    // },\n     //==== OTHER FORMS ===============//\n    // {\n    //   uid: 'kobo-id',\n    //   formName: 'Form Name', //Kobo form name\n    //   projectid: 'asana-id-from-url' //Asana project ID\n    // },\n    //================================//\n    ].map(survey => ({\n      ...survey,\n      formId: survey.uid,\n      url: `https://kf.kobotoolbox.org/api/v2/assets/${survey.uid}/data/?format=json`,\n      query: `&query={\"_submission_time\":{\"$gte\":\"${\n         state.lastEnd || manualCursor\n      }\"}}`,\n    })),\n  };\n  return state;\n});\n\neach(dataPath('surveys[*]'), state => {\n  const { url, query, tag, formId, formType, formName, owner, projectid } = state.data;\n  return get(`${url}${query}`, {}, state => {\n    state.data.submissions = state.data.results.map(submission => {\n      return {\n        // Here we append the tags defined above to the Kobo form submission data\n        projectid,\n        formName,\n        formOwner: owner,\n        formType,\n        body: submission,\n      };\n    });\n    const count = state.data.submissions.length;\n    console.log(`Fetched ${count} submissions from ${formName}.`);\n    //Once we fetch the data, we want to post each individual Kobo survey\n    //back to the OpenFn inbox to run through the jobs =========================\n    return each(dataPath('submissions[*]'), state => {\n      console.log(`Posting 1 of ${count}...`);\n      return post(state.configuration.openfnInboxUrl, {\n        body: state => state.data,\n      })(state);\n    })(state);\n    // =========================================================================\n  })(state);\n});\n\nfn(state => {\n  let lastEnd = state.references\n    .filter(item => item.body)\n    .map(s => s.body.end)\n    .sort((a, b) => new Date(b.date) - new Date(a.date))[0];\n\n  lastEnd = new Date(lastEnd) > new Date() ? lastEnd : new Date().toISOString();\n\n  console.log('New cursor value:', lastEnd);\n  return { ...state, data: {}, references: [], lastEnd };\n});\n",
          "adaptor": "@openfn/language-http@v3.1.12",
          "project_credential_id": null
        }
      },
      "edges": {
        "cron->Get-Kobo-Forms-Template": {
          "enabled": false,
          "id": "6a57147b-4307-4ceb-8450-f653d83e27cf",
          "target_job_id": "ef2461bd-6de4-4994-b526-334f6a03917b",
          "source_trigger_id": "cdeb0670-9b39-4f5c-a9a9-e11b8ec0ccf7",
          "condition_type": "always"
        }
      }
    },
    "z[Archive]-Get-kobo-form---test": {
      "id": "c0179d6d-d86f-4490-80ee-5b7243cb83df",
      "name": "z[Archive] Get kobo form - test",
      "inserted_at": "2025-03-18T09:54:02.590597Z",
      "lock_version": 7,
      "triggers": {
        "cron": {
          "enabled": false,
          "id": "ff7eb8e7-1123-4815-80b1-5911a6a1c43f",
          "type": "cron",
          "cron_expression": "0 2 * * *"
        }
      },
      "jobs": {
        "Get-kobo-form---test": {
          "id": "16e480d3-f17e-4f1e-a1a5-401e7e0c5989",
          "name": "Get kobo form - test",
          "body": "get('https://kf.kobotoolbox.org/api/v2/assets/a4oeehbiGuXrEWK7rkUv82/?format=json', \n{\n  headers: {'content-type': 'application/json'},\n}, state => {\n  console.log(state); \n  return state; \n  \n  })\n",
          "adaptor": "@openfn/language-http@v6.1.0",
          "project_credential_id": null
        }
      },
      "edges": {
        "cron->Get-kobo-form---test": {
          "enabled": true,
          "id": "9c179ae2-27d0-4843-b877-37ac611e32f8",
          "target_job_id": "16e480d3-f17e-4f1e-a1a5-401e7e0c5989",
          "source_trigger_id": "ff7eb8e7-1123-4815-80b1-5911a6a1c43f",
          "condition_type": "always"
        }
      }
    }
  },
  "requires_mfa": false
}